<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supplier Research Dashboard - 9kilos</title>
    <style>
        :root {
            --primary-bg: linear-gradient(135deg, #0a0a1a 0%, #0f3460 50%, #1a1a2e 100%);
            --header-bg: rgba(15, 52, 96, 0.95);
            --card-bg: rgba(255, 255, 255, 0.08);
            --accent-gold: #ffd93d;
            --accent-blue: #3498db;
            --text-primary: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.6);
            --border-light: rgba(255, 255, 255, 0.1);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .research-dashboard {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .dashboard-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: var(--header-bg);
            border-radius: 16px;
            border: 1px solid var(--border-light);
        }
        
        .dashboard-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcf7f, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .dashboard-header p {
            color: var(--text-muted);
            font-size: 1.1em;
        }
        
        .supplier-comparison {
            display: grid;
            gap: 25px;
        }
        
        .comparison-header {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 15px;
            font-weight: bold;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-light);
            font-size: 1.1em;
        }
        
        .metric-section {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid var(--border-light);
        }
        
        .metric-section h3 {
            margin: 0 0 20px 0;
            color: var(--accent-gold);
            font-size: 1.3em;
        }
        
        .metric-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 15px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-light);
            align-items: center;
        }
        
        .metric-row:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .metric-value {
            text-align: center;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .topembed { 
            background: rgba(52, 152, 219, 0.1);
            color: #3498db;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .streamed { 
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        
        .metric-difference {
            text-align: center;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .positive {
            background: rgba(39, 174, 96, 0.1);
            color: #27ae60;
            border: 1px solid rgba(39, 174, 96, 0.3);
        }
        
        .negative {
            background: rgba(192, 57, 43, 0.1);
            color: #c0392b;
            border: 1px solid rgba(192, 57, 43, 0.3);
        }
        
        .neutral {
            background: rgba(149, 165, 166, 0.1);
            color: #95a5a6;
            border: 1px solid rgba(149, 165, 166, 0.3);
        }
        
        .supplier-name.topembed { color: #3498db; }
        .supplier-name.streamed { color: #e74c3c; }
        
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        .refresh-btn, .export-btn {
            background: var(--accent-gold);
            color: black;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        
        .refresh-btn:hover, .export-btn:hover {
            transform: translateY(-2px);
        }
        
        .export-btn {
            background: var(--accent-blue);
            color: white;
        }
        
        .last-updated {
            text-align: center;
            color: var(--text-muted);
            margin-top: 20px;
            font-size: 0.9em;
        }
        
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .data-source {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8em;
            margin-bottom: 10px;
        }
        
        .update-schedule {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.7em;
            margin-top: 5px;
        }
        
        .trend-indicator {
            font-size: 0.8em;
            margin-left: 5px;
        }
        
        .trend-up { color: #27ae60; }
        .trend-down { color: #e74c3c; }
        .trend-neutral { color: #95a5a6; }
    </style>
</head>
<body>
    <div class="research-dashboard">
        <div class="dashboard-header">
            <h1>ðŸ”¬ Supplier Research Dashboard</h1>
            <p>Smart analytics comparing TopEmbed.pw vs Streamed.pk</p>
            <div class="data-source" id="data-source-info">Loading data from both APIs...</div>
            <div class="update-schedule" id="update-schedule">Streams update: 1hr live â€¢ Daily content â€¢ Weekly archives</div>
        </div>
        
        <div class="controls">
            <button class="refresh-btn" onclick="researchDashboard.refreshData()">ðŸ”„ Refresh Data</button>
            <button class="export-btn" onclick="researchDashboard.exportData()">ðŸ’¾ Export Research Data</button>
        </div>

        <div class="supplier-comparison">
            
            <!-- HEADER ROW -->
            <div class="comparison-header">
                <div class="supplier-name">METRIC</div>
                <div class="supplier-name topembed">TOPEMBED.PW</div>
                <div class="supplier-name streamed">STREAMED.PK</div>
                <div class="supplier-name">DIFFERENCE</div>
            </div>

            <!-- CONTENT VOLUME SECTION -->
            <div class="metric-section">
                <h3>ðŸ“Š Content Volume</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Total Matches</div>
                    <div class="metric-value topembed" id="topembed-total-matches">0</div>
                    <div class="metric-value streamed" id="streamed-total-matches">0</div>
                    <div class="metric-difference neutral" id="diff-total-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Live Matches</div>
                    <div class="metric-value topembed" id="topembed-live-matches">0</div>
                    <div class="metric-value streamed" id="streamed-live-matches">0</div>
                    <div class="metric-difference neutral" id="diff-live-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Upcoming Matches</div>
                    <div class="metric-value topembed" id="topembed-upcoming-matches">0</div>
                    <div class="metric-value streamed" id="streamed-upcoming-matches">0</div>
                    <div class="metric-difference neutral" id="diff-upcoming-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Working Streams</div>
                    <div class="metric-value topembed" id="topembed-working-streams">0</div>
                    <div class="metric-value streamed" id="streamed-working-streams">0</div>
                    <div class="metric-difference neutral" id="diff-working-streams">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Dead Streams</div>
                    <div class="metric-value topembed" id="topembed-dead-streams">0</div>
                    <div class="metric-value streamed" id="streamed-dead-streams">0</div>
                    <div class="metric-difference neutral" id="diff-dead-streams">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Multi-Stream Matches</div>
                    <div class="metric-value topembed" id="topembed-multi-stream">0</div>
                    <div class="metric-value streamed" id="streamed-multi-stream">0</div>
                    <div class="metric-difference neutral" id="diff-multi-stream">0</div>
                </div>
            </div>

            <!-- CONTENT COVERAGE SECTION -->
            <div class="metric-section">
                <h3>ðŸŽ¯ Content Coverage</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Sports Categories</div>
                    <div class="metric-value topembed" id="topembed-sports-count">0</div>
                    <div class="metric-value streamed" id="streamed-sports-count">0</div>
                    <div class="metric-difference neutral" id="diff-sports-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Different Leagues</div>
                    <div class="metric-value topembed" id="topembed-leagues-count">0</div>
                    <div class="metric-value streamed" id="streamed-leagues-count">0</div>
                    <div class="metric-difference neutral" id="diff-leagues-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Countries Covered</div>
                    <div class="metric-value topembed" id="topembed-countries-count">0</div>
                    <div class="metric-value streamed" id="streamed-countries-count">0</div>
                    <div class="metric-difference neutral" id="diff-countries-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">New Matches Today</div>
                    <div class="metric-value topembed" id="topembed-new-today">0</div>
                    <div class="metric-value streamed" id="streamed-new-today">0</div>
                    <div class="metric-difference neutral" id="diff-new-today">0</div>
                </div>
            </div>

            <!-- PERFORMANCE SECTION -->
            <div class="metric-section">
                <h3>âš¡ Performance & Reliability</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Stream Success Rate</div>
                    <div class="metric-value topembed" id="topembed-success-rate">0%</div>
                    <div class="metric-value streamed" id="streamed-success-rate">0%</div>
                    <div class="metric-difference neutral" id="diff-success-rate">0%</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Average Load Time</div>
                    <div class="metric-value topembed" id="topembed-load-time">0s</div>
                    <div class="metric-value streamed" id="streamed-load-time">0s</div>
                    <div class="metric-difference neutral" id="diff-load-time">0s</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Last Data Update</div>
                    <div class="metric-value topembed" id="topembed-last-update">Never</div>
                    <div class="metric-value streamed" id="streamed-last-update">Never</div>
                    <div class="metric-difference neutral">-</div>
                </div>
            </div>

            <!-- TRENDS SECTION (Only shows after 2+ days) -->
            <div class="metric-section" id="trends-section" style="display: none;">
                <h3>ðŸ“ˆ Weekly Trends</h3>
                <div id="trends-content"></div>
            </div>

        </div>

        <div class="last-updated">
            Last refreshed: <span id="last-refreshed">Never</span>
            â€¢ Next recommended refresh: <span id="next-refresh">1 hour</span>
        </div>
    </div>

    <script>
        // Research Tracker - Smart Data Analysis with Update Scheduling
        class ResearchTracker {
            constructor() {
                this.metrics = {
                    topembed: this.createSupplierMetrics(),
                    streamed: this.createSupplierMetrics()
                };
                this.testHistory = [];
                this.dailySnapshots = {};
                this.startTime = Date.now();
                this.dataSources = {
                    topembed: { success: false, matches: 0 },
                    streamed: { success: false, matches: 0 }
                };
                this.lastAPICallTime = 0;
                this.lastStreamTestTime = 0;
                
                // Load historical data
                this.loadHistoricalData();
                console.log('ðŸ”¬ Research Tracker initialized with smart scheduling');
            }

            createSupplierMetrics() {
                return {
                    totalMatches: 0,
                    liveMatches: 0,
                    upcomingMatches: 0,
                    deadStreams: 0,
                    workingStreams: 0,
                    multiStreamMatches: 0,
                    sportsCount: 0,
                    leaguesCount: 0,
                    countriesCount: 0,
                    newMatchesToday: 0,
                    successRate: 0,
                    averageLoadTime: 0,
                    totalTests: 0,
                    successfulTests: 0,
                    lastUpdateTime: null
                };
            }

            async analyzeSuppliers() {
                console.log('ðŸ”„ Smart data collection started...');
                this.resetCurrentMetrics();
                
                // SMART SCHEDULING: Only call APIs if needed
                const shouldCallAPIs = this.shouldCallAPIs();
                const shouldTestStreams = this.shouldTestStreams();
                
                let tomData = null;
                let sarahData = null;
                
                if (shouldCallAPIs) {
                    console.log('ðŸ“¡ Calling APIs (scheduled refresh)');
                    [tomData, sarahData] = await Promise.all([
                        this.fetchTopEmbedData(),
                        this.fetchStreamedData()
                    ]);
                    this.lastAPICallTime = Date.now();
                } else {
                    console.log('â¸ï¸  Using cached API data (recently updated)');
                    // Use data from last snapshot
                    const lastSnapshot = this.getLastSnapshot();
                    if (lastSnapshot) {
                        tomData = lastSnapshot.tomData;
                        sarahData = lastSnapshot.sarahData;
                    }
                }
                
                console.log('ðŸ“Š Data availability:', {
                    tom: tomData ? 'âœ…' : 'âŒ',
                    sarah: sarahData ? 'âœ…' : 'âŒ',
                    apiCalls: shouldCallAPIs ? 'âœ…' : 'â¸ï¸',
                    streamTests: shouldTestStreams ? 'âœ…' : 'â¸ï¸'
                });
                
                // Convert and merge data
                const allMatches = this.mergeSupplierData(tomData, sarahData);
                
                if (allMatches.length === 0) {
                    console.warn('No matches available from either supplier');
                    return this.metrics;
                }

                // Analyze content (always do this)
                this.analyzeSupplier(allMatches, 'topembed');
                this.analyzeSupplier(allMatches, 'streamed');
                
                // SMART STREAM TESTING: Only test if scheduled
                if (shouldTestStreams) {
                    console.log('ðŸ” Testing streams (scheduled test)');
                    await this.analyzeStreamQuality(allMatches, 'topembed');
                    await this.analyzeStreamQuality(allMatches, 'streamed');
                    this.lastStreamTestTime = Date.now();
                } else {
                    console.log('â¸ï¸  Using cached stream test results');
                    // Use stream metrics from last analysis
                    this.useCachedStreamMetrics();
                }
                
                const now = new Date();
                this.metrics.topembed.lastUpdateTime = now;
                this.metrics.streamed.lastUpdateTime = now;
                
                this.updateDataSourceInfo();
                
                // Save snapshot with scheduling info
                this.saveDailySnapshot(tomData, sarahData);
                
                return this.metrics;
            }

            // SMART SCHEDULING RULES
            shouldCallAPIs() {
                const now = Date.now();
                const timeSinceLastCall = now - this.lastAPICallTime;
                
                // Call APIs if:
                // - Never called before
                // - Last call was more than 1 hour ago (respects stream update schedule)
                // - No cached data available
                if (this.lastAPICallTime === 0) return true;
                if (timeSinceLastCall > (60 * 60 * 1000)) return true; // 1 hour
                if (Object.keys(this.dailySnapshots).length === 0) return true;
                
                return false;
            }

            shouldTestStreams() {
                const now = Date.now();
                const timeSinceLastTest = now - this.lastStreamTestTime;
                
                // Test streams if:
                // - Never tested before
                // - Last test was more than 2 hours ago
                // - It's a new day and we want fresh reliability data
                if (this.lastStreamTestTime === 0) return true;
                if (timeSinceLastTest > (2 * 60 * 60 * 1000)) return true; // 2 hours
                
                const lastTestDate = new Date(this.lastStreamTestTime).toDateString();
                const today = new Date().toDateString();
                if (lastTestDate !== today) return true; // New day
                
                return false;
            }

            getLastSnapshot() {
                const today = new Date().toDateString();
                return this.dailySnapshots[today] || Object.values(this.dailySnapshots).pop();
            }

            useCachedStreamMetrics() {
                const lastSnapshot = this.getLastSnapshot();
                if (lastSnapshot) {
                    ['topembed', 'streamed'].forEach(supplier => {
                        const cached = lastSnapshot.metrics[supplier];
                        this.metrics[supplier].workingStreams = cached.workingStreams;
                        this.metrics[supplier].deadStreams = cached.deadStreams;
                        this.metrics[supplier].successRate = cached.successRate;
                        this.metrics[supplier].averageLoadTime = cached.averageLoadTime;
                        this.metrics[supplier].totalTests = cached.totalTests;
                        this.metrics[supplier].successfulTests = cached.successfulTests;
                    });
                }
            }

            async fetchTopEmbedData() {
                try {
                    console.log('ðŸ”µ Fetching TopEmbed data...');
                    const response = await fetch('https://corsproxy.io/?https://topembed.pw/api.php?format=json');
                    if (response.ok) {
                        const data = await response.json();
                        this.dataSources.topembed.success = true;
                        this.dataSources.topembed.matches = this.countMatches(data);
                        console.log('âœ… TopEmbed:', this.dataSources.topembed.matches, 'matches');
                        return data;
                    }
                } catch (error) {
                    console.log('âŒ TopEmbed failed:', error.message);
                }
                return null;
            }

            async fetchStreamedData() {
                try {
                    console.log('ðŸ”´ Fetching Streamed data...');
                    const response = await fetch('https://streamed.pk/api/matches/all');
                    if (response.ok) {
                        const data = await response.json();
                        this.dataSources.streamed.success = true;
                        this.dataSources.streamed.matches = data.length || 0;
                        console.log('âœ… Streamed:', this.dataSources.streamed.matches, 'matches');
                        return data;
                    }
                } catch (error) {
                    console.log('âŒ Streamed failed:', error.message);
                }
                return null;
            }

            countMatches(apiData) {
                if (!apiData?.events) return 0;
                return Object.values(apiData.events).reduce((total, matches) => total + matches.length, 0);
            }

            mergeSupplierData(tomData, sarahData) {
                const allMatches = [];
                
                // Add TopEmbed matches
                if (tomData?.events) {
                    Object.entries(tomData.events).forEach(([date, events]) => {
                        events.forEach(event => {
                            allMatches.push({
                                id: 'tom-' + event.match + '-' + event.unix_timestamp,
                                date: date,
                                time: new Date(event.unix_timestamp * 1000).toLocaleTimeString('en-US', { 
                                    hour: '2-digit', minute: '2-digit', hour12: false 
                                }),
                                teams: event.match,
                                league: event.tournament,
                                sport: event.sport,
                                isLive: Math.floor(Date.now() / 1000) >= event.unix_timestamp,
                                channels: event.channels || ['https://topembed.pw/embed/' + (event.sport?.toLowerCase() || 'football')],
                                unixTimestamp: event.unix_timestamp,
                                source: 'topembed'
                            });
                        });
                    });
                }
                
                // Add Streamed matches
                if (sarahData && Array.isArray(sarahData)) {
                    sarahData.forEach(match => {
                        const date = new Date(match.date).toISOString().split('T')[0];
                        const teamNames = match.teams ? 
                            `${match.teams.home?.name || 'Team A'} - ${match.teams.away?.name || 'Team B'}` : 
                            match.title;
                        
                        const channels = match.sources ? 
                            match.sources.map(source => `https://streamed.pk/api/stream/${source.source}/${source.id}`) : 
                            ['https://streamed.pk/api/stream/default/123'];
                        
                        allMatches.push({
                            id: 'sarah-' + (match.id || Date.now()),
                            date: date,
                            time: new Date(match.date).toLocaleTimeString('en-US', { 
                                hour: '2-digit', minute: '2-digit', hour12: false 
                            }),
                            teams: teamNames,
                            league: match.category,
                            sport: match.category,
                            isLive: Date.now() >= new Date(match.date).getTime(),
                            channels: channels,
                            unixTimestamp: Math.floor(new Date(match.date).getTime() / 1000),
                            source: 'streamed'
                        });
                    });
                }
                
                console.log('ðŸ”— Merged data:', allMatches.length, 'total matches');
                return allMatches;
            }

            analyzeSupplier(matches, supplier) {
                const supplierMatches = matches.filter(match => 
                    match.channels && match.channels.some(channel => this.identifySupplier(channel) === supplier)
                );

                console.log(`ðŸ“ˆ ${supplier}:`, supplierMatches.length, 'matches');

                this.metrics[supplier].totalMatches = supplierMatches.length;
                this.metrics[supplier].liveMatches = supplierMatches.filter(m => m.isLive).length;
                this.metrics[supplier].upcomingMatches = supplierMatches.filter(m => !m.isLive).length;
                
                this.analyzeContentCoverage(supplierMatches, supplier);
            }

            analyzeContentCoverage(matches, supplier) {
                const sports = new Set();
                const leagues = new Set();
                const countries = new Set();

                matches.forEach(match => {
                    sports.add(match.sport);
                    leagues.add(match.league);
                    const country = this.extractCountryFromLeague(match.league);
                    if (country) countries.add(country);
                });

                this.metrics[supplier].sportsCount = sports.size;
                this.metrics[supplier].leaguesCount = leagues.size;
                this.metrics[supplier].countriesCount = countries.size;
                
                // Calculate new matches today
                this.calculateNewMatchesToday(supplier, matches);
            }

            calculateNewMatchesToday(supplier, matches) {
                const today = new Date().toDateString();
                const todayMatches = matches.filter(match => {
                    const matchDate = new Date(match.date).toDateString();
                    return matchDate === today;
                });
                
                this.metrics[supplier].newMatchesToday = todayMatches.length;
            }

            async analyzeStreamQuality(matches, supplier) {
                let deadStreams = 0;
                let workingStreams = 0;
                let multiStreamMatches = 0;
                let totalLoadTime = 0;
                let successfulTests = 0;
                let totalTests = 0;

                // SMART TESTING: Only test 3 matches to respect server limits
                const testMatches = matches.slice(0, 3);
                
                console.log(`ðŸ” Testing ${testMatches.length} ${supplier} streams...`);
                
                for (const match of testMatches) {
                    const supplierStreams = match.channels.filter(channel => 
                        this.identifySupplier(channel) === supplier
                    );

                    if (supplierStreams.length > 1) {
                        this.metrics[supplier].multiStreamMatches++;
                    }

                    // Test only 1 stream per match to be respectful
                    for (const streamUrl of supplierStreams.slice(0, 1)) {
                        totalTests++;
                        const testResult = await this.smartStreamTest(streamUrl, supplier);
                        
                        if (testResult.healthy) {
                            workingStreams++;
                            successfulTests++;
                            totalLoadTime += testResult.loadTime;
                            console.log(`âœ… ${supplier} stream worked:`, Math.round(testResult.loadTime) + 'ms');
                        } else {
                            deadStreams++;
                            console.log(`âŒ ${supplier} stream failed`);
                        }
                        await this.delay(1000); // Respectful delay between tests
                    }
                }

                this.metrics[supplier].deadStreams = deadStreams;
                this.metrics[supplier].workingStreams = workingStreams;
                this.metrics[supplier].multiStreamMatches = multiStreamMatches;
                this.metrics[supplier].successRate = totalTests > 0 ? (successfulTests / totalTests) * 100 : 0;
                this.metrics[supplier].averageLoadTime = successfulTests > 0 ? totalLoadTime / successfulTests : 0;
                this.metrics[supplier].totalTests = totalTests;
                this.metrics[supplier].successfulTests = successfulTests;
            }

            async smartStreamTest(streamUrl, supplier) {
                const startTime = Date.now();
                
                return new Promise((resolve) => {
                    // Use iframe method which is more reliable for stream testing
                    const iframe = document.createElement('iframe');
                    iframe.style.display = 'none';
                    iframe.src = streamUrl;
                    
                    const timeout = setTimeout(() => {
                        document.body.removeChild(iframe);
                        resolve({ healthy: false, loadTime: 0 });
                    }, 8000); // 8 second timeout
                    
                    iframe.onload = () => {
                        clearTimeout(timeout);
                        document.body.removeChild(iframe);
                        const loadTime = Date.now() - startTime;
                        resolve({ healthy: true, loadTime });
                    };
                    
                    iframe.onerror = () => {
                        clearTimeout(timeout);
                        document.body.removeChild(iframe);
                        resolve({ healthy: false, loadTime: 0 });
                    };
                    
                    document.body.appendChild(iframe);
                });
            }

            identifySupplier(streamUrl) {
                if (streamUrl.includes('topembed')) return 'topembed';
                if (streamUrl.includes('streamed.pk')) return 'streamed';
                return 'unknown';
            }

            extractCountryFromLeague(leagueName) {
                const countryPatterns = {
                    'England': 'UK', 'English': 'UK', 'Premier League': 'UK',
                    'Spain': 'Spain', 'La Liga': 'Spain', 'Italy': 'Italy',
                    'Germany': 'Germany', 'France': 'France', 'USA': 'USA',
                    'NBA': 'USA', 'NFL': 'USA', 'MLB': 'USA'
                };
                
                for (const [pattern, country] of Object.entries(countryPatterns)) {
                    if (leagueName.includes(pattern)) return country;
                }
                return null;
            }

            updateDataSourceInfo() {
                const infoElement = document.getElementById('data-source-info');
                if (infoElement) {
                    const tomStatus = this.dataSources.topembed.success ? 
                        `TopEmbed: ${this.dataSources.topembed.matches} matches` : 'TopEmbed: Failed';
                    const sarahStatus = this.dataSources.streamed.success ? 
                        `Streamed: ${this.dataSources.streamed.matches} matches` : 'Streamed: Failed';
                    
                    const apiStatus = this.lastAPICallTime > 0 ? 'âœ…' : 'â¸ï¸';
                    const testStatus = this.lastStreamTestTime > 0 ? 'âœ…' : 'â¸ï¸';
                    
                    infoElement.textContent = `${apiStatus} APIs | ${testStatus} Stream Tests | ${tomStatus} | ${sarahStatus}`;
                }
            }

            // DATA PERSISTENCE METHODS
            saveDailySnapshot(tomData, sarahData) {
                const today = new Date().toDateString();
                const snapshot = {
                    date: today,
                    timestamp: Date.now(),
                    metrics: JSON.parse(JSON.stringify(this.metrics)),
                    dataSources: JSON.parse(JSON.stringify(this.dataSources)),
                    tomData: tomData, // Store raw data for caching
                    sarahData: sarahData,
                    lastAPICallTime: this.lastAPICallTime,
                    lastStreamTestTime: this.lastStreamTestTime
                };
                
                this.dailySnapshots[today] = snapshot;
                
                // Save to localStorage
                this.saveToStorage('researchSnapshots', this.dailySnapshots);
                this.saveToStorage('researchTestHistory', this.testHistory);
                this.saveToStorage('researchSettings', {
                    lastAPICallTime: this.lastAPICallTime,
                    lastStreamTestTime: this.lastStreamTestTime,
                    startTime: this.startTime
                });
                
                console.log('ðŸ’¾ Saved daily snapshot for', today);
            }

            loadHistoricalData() {
                // Load from localStorage
                const savedSnapshots = this.loadFromStorage('researchSnapshots');
                const savedHistory = this.loadFromStorage('researchTestHistory');
                const savedSettings = this.loadFromStorage('researchSettings');
                
                if (savedSnapshots) {
                    this.dailySnapshots = savedSnapshots;
                    console.log('ðŸ“Š Loaded', Object.keys(savedSnapshots).length, 'historical snapshots');
                }
                
                if (savedHistory) {
                    this.testHistory = savedHistory.slice(-1000);
                    console.log('ðŸ“ˆ Loaded', savedHistory.length, 'historical tests');
                }
                
                if (savedSettings) {
                    this.lastAPICallTime = savedSettings.lastAPICallTime || 0;
                    this.lastStreamTestTime = savedSettings.lastStreamTestTime || 0;
                    this.startTime = savedSettings.startTime || this.startTime;
                    console.log('âš™ï¸  Loaded research settings');
                }
            }

            saveToStorage(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                } catch (error) {
                    console.warn('Storage save failed:', error);
                }
            }

            loadFromStorage(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Storage load failed:', error);
                    return null;
                }
            }

            recordTest(testData) {
                this.testHistory.push(testData);
                if (this.testHistory.length > 500) {
                    this.testHistory = this.testHistory.slice(-250);
                }
            }

            resetCurrentMetrics() {
                ['topembed', 'streamed'].forEach(supplier => {
                    Object.keys(this.metrics[supplier]).forEach(key => {
                        if (typeof this.metrics[supplier][key] === 'number') {
                            this.metrics[supplier][key] = 0;
                        }
                    });
                });
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // WEEKLY TRENDS AND ANALYSIS
            getWeeklyTrends() {
                const last7Days = this.getLastNDays(7);
                if (last7Days.length < 2) return null;
                
                const trends = {
                    topembed: this.calculateSupplierTrends('topembed', last7Days),
                    streamed: this.calculateSupplierTrends('streamed', last7Days),
                    hasData: true
                };
                
                return trends;
            }

            getLastNDays(n) {
                const days = [];
                for (let i = 0; i < n; i++) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    const dateKey = date.toDateString();
                    if (this.dailySnapshots[dateKey]) {
                        days.push(this.dailySnapshots[dateKey]);
                    }
                }
                return days;
            }

            calculateSupplierTrends(supplier, dailySnapshots) {
                if (dailySnapshots.length < 2) return { available: false };
                
                const firstDay = dailySnapshots[dailySnapshots.length - 1];
                const lastDay = dailySnapshots[0];
                
                return {
                    available: true,
                    totalMatches: this.calculateChange(firstDay.metrics[supplier].totalMatches, lastDay.metrics[supplier].totalMatches),
                    successRate: this.calculateChange(firstDay.metrics[supplier].successRate, lastDay.metrics[supplier].successRate),
                    sportsCount: this.calculateChange(firstDay.metrics[supplier].sportsCount, lastDay.metrics[supplier].sportsCount),
                    daysAnalyzed: dailySnapshots.length
                };
            }

            calculateChange(oldValue, newValue) {
                if (oldValue === 0) return { change: 0, percent: 0, trend: 'neutral' };
                const change = newValue - oldValue;
                const percent = (change / oldValue) * 100;
                const trend = change > 0 ? 'up' : change < 0 ? 'down' : 'neutral';
                return { change, percent: Math.round(percent), trend };
            }

            getNextRecommendedRefresh() {
                const now = Date.now();
                const timeSinceLastCall = now - this.lastAPICallTime;
                const timeSinceLastTest = now - this.lastStreamTestTime;
                
                // Recommend refresh based on what's needed
                if (timeSinceLastCall > (55 * 60 * 1000)) { // 55 minutes
                    return '1 hour (API refresh)';
                } else if (timeSinceLastTest > (115 * 60 * 1000)) { // 115 minutes
                    return '2 hours (stream test)';
                } else {
                    const nextAPIRefresh = Math.ceil((60 - (timeSinceLastCall / (60 * 1000))) / 5) * 5;
                    return `${nextAPIRefresh} minutes`;
                }
            }

            // ENHANCED EXPORT WITH SMART SCHEDULING INFO
            exportResearchData() {
                const weeklyTrends = this.getWeeklyTrends();
                const performanceHistory = this.getPerformanceHistory(7);
                
                return {
                    metadata: {
                        exportTime: new Date().toISOString(),
                        studyDuration: Date.now() - this.startTime,
                        totalSnapshots: Object.keys(this.dailySnapshots).length,
                        totalTests: this.testHistory.length,
                        dataSources: this.dataSources,
                        scheduling: {
                            lastAPICall: new Date(this.lastAPICallTime).toISOString(),
                            lastStreamTest: new Date(this.lastStreamTestTime).toISOString(),
                            nextRecommendedRefresh: this.getNextRecommendedRefresh()
                        }
                    },
                    
                    currentComparison: {
                        topembed: this.metrics.topembed,
                        streamed: this.metrics.streamed
                    },
                    
                    weeklyTrends: weeklyTrends,
                    
                    historicalData: {
                        dailySnapshots: this.dailySnapshots,
                        performanceHistory: performanceHistory
                    },
                    
                    analysis: {
                        topembed: {
                            reliabilityScore: this.calculateReliabilityScore('topembed'),
                            coverageScore: this.calculateCoverageScore('topembed'),
                            weeklyTrend: weeklyTrends?.topembed || 'Insufficient data'
                        },
                        streamed: {
                            reliabilityScore: this.calculateReliabilityScore('streamed'),
                            coverageScore: this.calculateCoverageScore('streamed'),
                            weeklyTrend: weeklyTrends?.streamed || 'Insufficient data'
                        }
                    },
                    
                    sampleTestData: this.testHistory.slice(-50)
                };
            }

            getPerformanceHistory(days = 7) {
                const history = [];
                const lastNDays = this.getLastNDays(days);
                
                lastNDays.forEach(snapshot => {
                    history.push({
                        date: snapshot.date,
                        topembed: {
                            successRate: snapshot.metrics.topembed.successRate,
                            totalMatches: snapshot.metrics.topembed.totalMatches
                        },
                        streamed: {
                            successRate: snapshot.metrics.streamed.successRate,
                            totalMatches: snapshot.metrics.streamed.totalMatches
                        }
                    });
                });
                
                return history;
            }

            calculateReliabilityScore(supplier) {
                const metrics = this.metrics[supplier];
                if (metrics.totalTests === 0) return 0;
                return (metrics.successRate * 0.7 + (100 - (metrics.averageLoadTime / 100)) * 0.3);
            }

            calculateCoverageScore(supplier) {
                const metrics = this.metrics[supplier];
                return (metrics.sportsCount * 4 + metrics.leaguesCount * 2 + metrics.countriesCount) * 10;
            }

            getMetrics() {
                return this.metrics;
            }
        }

        // Research Dashboard - UI Controller
        class ResearchDashboard {
            constructor() {
                this.tracker = new ResearchTracker();
                this.isLoading = false;
                this.init();
            }

            async init() {
                this.startSmartRefresh();
                await this.refreshData();
            }

            async refreshData() {
                if (this.isLoading) return;
                this.isLoading = true;
                this.updateLoadingState(true);
                
                try {
                    const metrics = await this.tracker.analyzeSuppliers();
                    this.updateDashboard(metrics);
                    this.updateLastRefreshed();
                    this.updateTrendsSection();
                    this.updateNextRefreshTime();
                } catch (error) {
                    console.error('Refresh error:', error);
                } finally {
                    this.isLoading = false;
                    this.updateLoadingState(false);
                }
            }

            updateDashboard(metrics) {
                if (!metrics) return;
                this.updateSupplierMetrics('topembed', metrics.topembed);
                this.updateSupplierMetrics('streamed', metrics.streamed);
                this.updateDifferenceColumns();
            }

            updateSupplierMetrics(supplier, data) {
                const elements = {
                    'total-matches': data.totalMatches,
                    'live-matches': data.liveMatches,
                    'upcoming-matches': data.upcomingMatches,
                    'working-streams': data.workingStreams,
                    'dead-streams': data.deadStreams,
                    'multi-stream': data.multiStreamMatches,
                    'sports-count': data.sportsCount,
                    'leagues-count': data.leaguesCount,
                    'countries-count': data.countriesCount,
                    'new-today': data.newMatchesToday,
                    'success-rate': data.successRate.toFixed(1) + '%',
                    'load-time': (data.averageLoadTime / 1000).toFixed(1) + 's',
                    'last-update': data.lastUpdateTime ? data.lastUpdateTime.toLocaleTimeString() : 'Never'
                };

                for (const [metric, value] of Object.entries(elements)) {
                    const element = document.getElementById(`${supplier}-${metric}`);
                    if (element) element.textContent = value;
                }
            }

            updateDifferenceColumns() {
                const metrics = [
                    'total-matches', 'live-matches', 'upcoming-matches', 
                    'working-streams', 'dead-streams', 'multi-stream',
                    'sports-count', 'leagues-count', 'countries-count', 'new-today'
                ];

                metrics.forEach(metric => {
                    const topembedValue = this.extractNumber(document.getElementById(`topembed-${metric}`).textContent);
                    const streamedValue = this.extractNumber(document.getElementById(`streamed-${metric}`).textContent);
                    const difference = topembedValue - streamedValue;
                    this.updateDifferenceElement(document.getElementById(`diff-${metric}`), difference);
                });

                // Handle special metrics
                const topembedSuccess = this.extractNumber(document.getElementById('topembed-success-rate').textContent);
                const streamedSuccess = this.extractNumber(document.getElementById('streamed-success-rate').textContent);
                this.updateDifferenceElement(document.getElementById('diff-success-rate'), topembedSuccess - streamedSuccess, '%');

                const topembedLoad = this.extractNumber(document.getElementById('topembed-load-time').textContent);
                const streamedLoad = this.extractNumber(document.getElementById('streamed-load-time').textContent);
                this.updateDifferenceElement(document.getElementById('diff-load-time'), -(topembedLoad - streamedLoad), 's');
            }

            updateDifferenceElement(element, difference, suffix = '') {
                let displayValue = difference >= 0 ? `+${difference}${suffix}` : `${difference}${suffix}`;
                element.textContent = displayValue;
                element.className = `metric-difference ${difference > 0 ? 'positive' : difference < 0 ? 'negative' : 'neutral'}`;
            }

            updateTrendsSection() {
                const trends = this.tracker.getWeeklyTrends();
                const trendsSection = document.getElementById('trends-section');
                const trendsContent = document.getElementById('trends-content');
                
                if (trends && trends.hasData) {
                    trendsSection.style.display = 'block';
                    trendsContent.innerHTML = this.generateTrendsHTML(trends);
                } else {
                    trendsSection.style.display = 'none';
                }
            }

            generateTrendsHTML(trends) {
                let html = '';
                
                ['topembed', 'streamed'].forEach(supplier => {
                    const supplierTrends = trends[supplier];
                    if (supplierTrends.available) {
                        html += `<div class="metric-row">
                            <div class="metric-label">${supplier.toUpperCase()} Weekly Trend</div>
                            <div class="metric-value topembed">
                                Matches: ${supplierTrends.totalMatches.change >= 0 ? '+' : ''}${supplierTrends.totalMatches.change}
                                <span class="trend-indicator ${supplierTrends.totalMatches.trend}">${this.getTrendIcon(supplierTrends.totalMatches.trend)}</span>
                            </div>
                            <div class="metric-value streamed">
                                Success: ${supplierTrends.successRate.change >= 0 ? '+' : ''}${supplierTrends.successRate.change}%
                                <span class="trend-indicator ${supplierTrends.successRate.trend}">${this.getTrendIcon(supplierTrends.successRate.trend)}</span>
                            </div>
                            <div class="metric-difference neutral">${supplierTrends.daysAnalyzed} days</div>
                        </div>`;
                    }
                });
                
                return html || '<div class="metric-row"><div class="metric-label">Collecting trend data...</div><div class="metric-value topembed">-</div><div class="metric-value streamed">-</div><div class="metric-difference neutral">-</div></div>';
            }

            getTrendIcon(trend) {
                return trend === 'up' ? 'â†—ï¸' : trend === 'down' ? 'â†˜ï¸' : 'âž¡ï¸';
            }

            updateNextRefreshTime() {
                const nextRefresh = this.tracker.getNextRecommendedRefresh();
                document.getElementById('next-refresh').textContent = nextRefresh;
            }

            extractNumber(text) {
                const match = text.match(/-?\d+(\.\d+)?/);
                return match ? parseFloat(match[0]) : 0;
            }

            updateLoadingState(loading) {
                const buttons = document.querySelectorAll('.refresh-btn, .export-btn');
                buttons.forEach(btn => {
                    btn.disabled = loading;
                    btn.classList.toggle('loading', loading);
                });
                document.querySelector('.refresh-btn').textContent = loading ? 'ðŸ”„ Smart Refresh...' : 'ðŸ”„ Refresh Data';
            }

            updateLastRefreshed() {
                document.getElementById('last-refreshed').textContent = new Date().toLocaleTimeString();
            }

            startSmartRefresh() {
                // Smart refresh every 5 minutes to check if updates are needed
                setInterval(() => {
                    this.updateNextRefreshTime();
                }, 5 * 60 * 1000); // 5 minutes
            }

            exportData() {
                try {
                    const researchData = this.tracker.exportResearchData();
                    const dataStr = JSON.stringify(researchData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `supplier-research-${Date.now()}.json`;
                    link.click();
                } catch (error) {
                    console.error('Export failed:', error);
                }
            }
        }

        // Initialize dashboard
        let researchDashboard;
        document.addEventListener('DOMContentLoaded', () => {
            researchDashboard = new ResearchDashboard();
        });
    </script>
</body>
</html>
