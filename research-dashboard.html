<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supplier Research Dashboard - 9kilos</title>
    <style>
        :root {
            --primary-bg: linear-gradient(135deg, #0a0a1a 0%, #0f3460 50%, #1a1a2e 100%);
            --header-bg: rgba(15, 52, 96, 0.95);
            --card-bg: rgba(255, 255, 255, 0.08);
            --accent-gold: #ffd93d;
            --accent-blue: #3498db;
            --text-primary: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.6);
            --border-light: rgba(255, 255, 255, 0.1);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .research-dashboard {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .dashboard-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: var(--header-bg);
            border-radius: 16px;
            border: 1px solid var(--border-light);
        }
        
        .dashboard-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcf7f, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .dashboard-header p {
            color: var(--text-muted);
            font-size: 1.1em;
        }
        
        .supplier-comparison {
            display: grid;
            gap: 25px;
        }
        
        .comparison-header {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 15px;
            font-weight: bold;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-light);
            font-size: 1.1em;
        }
        
        .metric-section {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid var(--border-light);
        }
        
        .metric-section h3 {
            margin: 0 0 20px 0;
            color: var(--accent-gold);
            font-size: 1.3em;
        }
        
        .metric-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 15px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-light);
            align-items: center;
        }
        
        .metric-row:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .metric-value {
            text-align: center;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .topembed { 
            background: rgba(52, 152, 219, 0.1);
            color: #3498db;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .streamed { 
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        
        .metric-difference {
            text-align: center;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .positive {
            background: rgba(39, 174, 96, 0.1);
            color: #27ae60;
            border: 1px solid rgba(39, 174, 96, 0.3);
        }
        
        .negative {
            background: rgba(192, 57, 43, 0.1);
            color: #c0392b;
            border: 1px solid rgba(192, 57, 43, 0.3);
        }
        
        .neutral {
            background: rgba(149, 165, 166, 0.1);
            color: #95a5a6;
            border: 1px solid rgba(149, 165, 166, 0.3);
        }
        
        .supplier-name.topembed { color: #3498db; }
        .supplier-name.streamed { color: #e74c3c; }
        
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        .refresh-btn, .export-btn {
            background: var(--accent-gold);
            color: black;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        
        .refresh-btn:hover, .export-btn:hover {
            transform: translateY(-2px);
        }
        
        .export-btn {
            background: var(--accent-blue);
            color: white;
        }
        
        .last-updated {
            text-align: center;
            color: var(--text-muted);
            margin-top: 20px;
            font-size: 0.9em;
        }
        
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .data-source {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8em;
            margin-bottom: 10px;
        }
        
        .update-schedule {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.7em;
            margin-top: 5px;
        }
        
        .trend-indicator {
            font-size: 0.8em;
            margin-left: 5px;
        }
        
        .trend-up { color: #27ae60; }
        .trend-down { color: #e74c3c; }
        .trend-neutral { color: #95a5a6; }
        
        .stealth-status {
            text-align: center;
            color: #f39c12;
            font-size: 0.8em;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .bandwidth-meter {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.7em;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="research-dashboard">
        <div class="dashboard-header">
            <h1>üî¨ Supplier Research Dashboard</h1>
            <p>Stealth mode analytics - Minimal footprint research</p>
            <div class="data-source" id="data-source-info">Initializing stealth mode...</div>
            <div class="update-schedule" id="update-schedule">STEALTH MODE: 3 API calls/day ‚Ä¢ 2 stream tests/day ‚Ä¢ Random timing</div>
            <div class="stealth-status" id="stealth-status">üïµÔ∏è STEALTH ACTIVE - Under radar mode</div>
            <div class="bandwidth-meter" id="bandwidth-meter">Bandwidth: 0MB/5MB used today</div>
        </div>
        
        <div class="controls">
            <button class="refresh-btn" onclick="researchDashboard.refreshData()">üîÑ Stealth Refresh</button>
            <button class="export-btn" onclick="researchDashboard.exportData()">üíæ Export Research</button>
        </div>

        <div class="supplier-comparison">
            
            <!-- HEADER ROW -->
            <div class="comparison-header">
                <div class="supplier-name">METRIC</div>
                <div class="supplier-name topembed">TOPEMBED.PW</div>
                <div class="supplier-name streamed">STREAMED.PK</div>
                <div class="supplier-name">DIFFERENCE</div>
            </div>

            <!-- CONTENT VOLUME SECTION -->
            <div class="metric-section">
                <h3>üìä Content Volume</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Total Matches</div>
                    <div class="metric-value topembed" id="topembed-total-matches">0</div>
                    <div class="metric-value streamed" id="streamed-total-matches">0</div>
                    <div class="metric-difference neutral" id="diff-total-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Live Matches</div>
                    <div class="metric-value topembed" id="topembed-live-matches">0</div>
                    <div class="metric-value streamed" id="streamed-live-matches">0</div>
                    <div class="metric-difference neutral" id="diff-live-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Upcoming Matches</div>
                    <div class="metric-value topembed" id="topembed-upcoming-matches">0</div>
                    <div class="metric-value streamed" id="streamed-upcoming-matches">0</div>
                    <div class="metric-difference neutral" id="diff-upcoming-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Working Streams</div>
                    <div class="metric-value topembed" id="topembed-working-streams">0</div>
                    <div class="metric-value streamed" id="streamed-working-streams">0</div>
                    <div class="metric-difference neutral" id="diff-working-streams">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Dead Streams</div>
                    <div class="metric-value topembed" id="topembed-dead-streams">0</div>
                    <div class="metric-value streamed" id="streamed-dead-streams">0</div>
                    <div class="metric-difference neutral" id="diff-dead-streams">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Multi-Stream Matches</div>
                    <div class="metric-value topembed" id="topembed-multi-stream">0</div>
                    <div class="metric-value streamed" id="streamed-multi-stream">0</div>
                    <div class="metric-difference neutral" id="diff-multi-stream">0</div>
                </div>
            </div>

            <!-- CONTENT COVERAGE SECTION -->
            <div class="metric-section">
                <h3>üéØ Content Coverage</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Sports Categories</div>
                    <div class="metric-value topembed" id="topembed-sports-count">0</div>
                    <div class="metric-value streamed" id="streamed-sports-count">0</div>
                    <div class="metric-difference neutral" id="diff-sports-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Different Leagues</div>
                    <div class="metric-value topembed" id="topembed-leagues-count">0</div>
                    <div class="metric-value streamed" id="streamed-leagues-count">0</div>
                    <div class="metric-difference neutral" id="diff-leagues-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Countries Covered</div>
                    <div class="metric-value topembed" id="topembed-countries-count">0</div>
                    <div class="metric-value streamed" id="streamed-countries-count">0</div>
                    <div class="metric-difference neutral" id="diff-countries-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">New Matches Today</div>
                    <div class="metric-value topembed" id="topembed-new-today">0</div>
                    <div class="metric-value streamed" id="streamed-new-today">0</div>
                    <div class="metric-difference neutral" id="diff-new-today">0</div>
                </div>
            </div>

            <!-- PERFORMANCE SECTION -->
            <div class="metric-section">
                <h3>‚ö° Performance & Reliability</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Stream Success Rate</div>
                    <div class="metric-value topembed" id="topembed-success-rate">0%</div>
                    <div class="metric-value streamed" id="streamed-success-rate">0%</div>
                    <div class="metric-difference neutral" id="diff-success-rate">0%</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Average Load Time</div>
                    <div class="metric-value topembed" id="topembed-load-time">0s</div>
                    <div class="metric-value streamed" id="streamed-load-time">0s</div>
                    <div class="metric-difference neutral" id="diff-load-time">0s</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Last Data Update</div>
                    <div class="metric-value topembed" id="topembed-last-update">Never</div>
                    <div class="metric-value streamed" id="streamed-last-update">Never</div>
                    <div class="metric-difference neutral">-</div>
                </div>
            </div>

            <!-- TRENDS SECTION -->
            <div class="metric-section" id="trends-section" style="display: none;">
                <h3>üìà Weekly Trends</h3>
                <div id="trends-content"></div>
            </div>

        </div>

        <div class="last-updated">
            Last refreshed: <span id="last-refreshed">Never</span>
            ‚Ä¢ Next stealth refresh: <span id="next-refresh">Calculating...</span>
        </div>
    </div>

    <script>
        // BANDWIDTH MONITOR - Protect GitHub limits
        class BandwidthMonitor {
            constructor() {
                this.dailyUsage = 0;
                this.maxDailyMB = 5; // 5MB/day max for GitHub Pages
                this.resetDailyIfNeeded();
            }
            
            resetDailyIfNeeded() {
                const lastReset = localStorage.getItem('bandwidthLastReset');
                const today = new Date().toDateString();
                
                if (lastReset !== today) {
                    this.dailyUsage = 0;
                    localStorage.setItem('bandwidthLastReset', today);
                    localStorage.setItem('bandwidthDailyUsage', '0');
                    console.log('üîÑ Bandwidth counter reset for new day');
                } else {
                    const savedUsage = localStorage.getItem('bandwidthDailyUsage');
                    this.dailyUsage = savedUsage ? parseFloat(savedUsage) : 0;
                }
            }
            
            trackRequest(url, estimatedSizeKB = 50) {
                this.resetDailyIfNeeded();
                
                const sizeMB = estimatedSizeKB / 1024;
                this.dailyUsage += sizeMB;
                
                localStorage.setItem('bandwidthDailyUsage', this.dailyUsage.toString());
                
                console.log(`üìä Bandwidth: ${this.dailyUsage.toFixed(2)}MB/${this.maxDailyMB}MB used`);
                this.updateBandwidthDisplay();
                
                if (this.dailyUsage > this.maxDailyMB) {
                    console.warn('üö® Bandwidth limit reached - stealth mode activated');
                    return false;
                }
                return true;
            }
            
            getRemainingMB() {
                return Math.max(0, this.maxDailyMB - this.dailyUsage);
            }
            
            updateBandwidthDisplay() {
                const element = document.getElementById('bandwidth-meter');
                if (element) {
                    const remaining = this.getRemainingMB();
                    element.textContent = `Bandwidth: ${this.dailyUsage.toFixed(2)}MB/${this.maxDailyMB}MB used (${remaining.toFixed(2)}MB remaining)`;
                    
                    if (remaining < 1) {
                        element.style.color = '#e74c3c';
                    } else if (remaining < 2) {
                        element.style.color = '#f39c12';
                    } else {
                        element.style.color = 'var(--text-muted)';
                    }
                }
            }
        }

        // Research Tracker - STEALTH MODE
        class ResearchTracker {
            constructor() {
                this.metrics = {
                    topembed: this.createSupplierMetrics(),
                    streamed: this.createSupplierMetrics()
                };
                this.testHistory = [];
                this.dailySnapshots = {};
                this.startTime = Date.now();
                this.dataSources = {
                    topembed: { success: false, matches: 0 },
                    streamed: { success: false, matches: 0 }
                };
                this.lastAPICallTime = 0;
                this.lastStreamTestTime = 0;
                this.apiCallsToday = 0;
                this.streamTestsToday = 0;
                this.bandwidthMonitor = new BandwidthMonitor();
                
                this.loadHistoricalData();
                console.log('üïµÔ∏è Research Tracker initialized - STEALTH MODE ACTIVE');
            }

            createSupplierMetrics() {
                return {
                    totalMatches: 0,
                    liveMatches: 0,
                    upcomingMatches: 0,
                    deadStreams: 0,
                    workingStreams: 0,
                    multiStreamMatches: 0,
                    sportsCount: 0,
                    leaguesCount: 0,
                    countriesCount: 0,
                    newMatchesToday: 0,
                    successRate: 0,
                    averageLoadTime: 0,
                    totalTests: 0,
                    successfulTests: 0,
                    lastUpdateTime: null
                };
            }

            async analyzeSuppliers() {
                console.log('üïµÔ∏è STEALTH data collection started...');
                this.resetCurrentMetrics();
                
                // STEALTH SCHEDULING CHECKS
                const shouldCallAPIs = this.shouldCallAPIs();
                const shouldTestStreams = this.shouldTestStreams();
                
                let tomData = null;
                let sarahData = null;
                
                if (shouldCallAPIs) {
                    console.log('üì° STEALTH API calls (limited mode)');
                    [tomData, sarahData] = await Promise.all([
                        this.stealthAPICall('topembed'),
                        this.stealthAPICall('streamed')
                    ]);
                    this.lastAPICallTime = Date.now();
                    this.apiCallsToday += 2; // Count both API calls
                } else {
                    console.log('‚è∏Ô∏è Using cached API data (stealth preservation)');
                    const lastSnapshot = this.getLastSnapshot();
                    if (lastSnapshot) {
                        tomData = lastSnapshot.tomData;
                        sarahData = lastSnapshot.sarahData;
                    }
                }
                
                console.log('üìä STEALTH data status:', {
                    tom: tomData ? '‚úÖ' : '‚ùå',
                    sarah: sarahData ? '‚úÖ' : '‚ùå',
                    apiCalls: shouldCallAPIs ? '‚úÖ' : '‚è∏Ô∏è',
                    streamTests: shouldTestStreams ? '‚úÖ' : '‚è∏Ô∏è',
                    bandwidth: `${this.bandwidthMonitor.dailyUsage.toFixed(2)}MB used`
                });
                
                // Convert and merge data
                const allMatches = this.mergeSupplierData(tomData, sarahData);
                
                if (allMatches.length === 0) {
                    console.warn('No matches available from either supplier');
                    return this.metrics;
                }

                // Analyze content (always do this - minimal cost)
                this.analyzeSupplier(allMatches, 'topembed');
                this.analyzeSupplier(allMatches, 'streamed');
                
                // ULTRA STEALTH STREAM TESTING
                if (shouldTestStreams) {
                    console.log('üîç STEALTH stream testing (minimal mode)');
                    await this.stealthStreamQualityCheck(allMatches, 'topembed');
                    await this.stealthStreamQualityCheck(allMatches, 'streamed');
                    this.lastStreamTestTime = Date.now();
                    this.streamTestsToday += 2; // Count both stream tests
                } else {
                    console.log('‚è∏Ô∏è Using cached stream results (stealth mode)');
                    this.useCachedStreamMetrics();
                }
                
                const now = new Date();
                this.metrics.topembed.lastUpdateTime = now;
                this.metrics.streamed.lastUpdateTime = now;
                
                this.updateDataSourceInfo();
                
                // Save snapshot with stealth info
                this.saveDailySnapshot(tomData, sarahData);
                
                return this.metrics;
            }

            // STEALTH SCHEDULING RULES
            shouldCallAPIs() {
                const now = Date.now();
                const timeSinceLastCall = now - this.lastAPICallTime;
                
                // STEALTH RULES:
                // 1. Max 3 API calls per day total
                // 2. Minimum 6 hours between calls
                // 3. Never call during maintenance (2AM-6AM)
                // 4. Random timing to avoid patterns
                // 5. Respect bandwidth limits
                
                if (this.apiCallsToday >= 3) {
                    console.log('‚è∏Ô∏è STEALTH: Max API calls reached for today (3/3)');
                    return false;
                }
                
                if (!this.bandwidthMonitor.trackRequest('api-call', 100)) {
                    console.log('‚è∏Ô∏è STEALTH: Bandwidth limit reached');
                    return false;
                }
                
                if (this.lastAPICallTime === 0) return true;
                
                const hoursSinceLastCall = timeSinceLastCall / (60 * 60 * 1000);
                if (hoursSinceLastCall < 6) {
                    console.log('‚è∏Ô∏è STEALTH: Too soon for API call (6h min)');
                    return false;
                }
                
                const currentHour = new Date().getHours();
                if (currentHour >= 2 && currentHour <= 6) {
                    console.log('‚è∏Ô∏è STEALTH: Avoiding maintenance hours');
                    return false;
                }
                
                // Random delay to avoid detection patterns
                const randomDelay = Math.random() * 2 * 60 * 60 * 1000; // ¬±2 hours
                if (timeSinceLastCall < (5 * 60 * 60 * 1000) + randomDelay) {
                    console.log('‚è∏Ô∏è STEALTH: Random timing delay active');
                    return false;
                }
                
                return true;
            }

            shouldTestStreams() {
                const now = Date.now();
                const timeSinceLastTest = now - this.lastStreamTestTime;
                
                // STEALTH RULES:
                // 1. Max 2 stream tests per day total
                // 2. Minimum 8 hours between tests
                // 3. Never test during peak hours (7-10PM)
                // 4. Very conservative testing
                
                if (this.streamTestsToday >= 2) {
                    console.log('‚è∏Ô∏è STEALTH: Max stream tests reached for today (2/2)');
                    return false;
                }
                
                if (!this.bandwidthMonitor.trackRequest('stream-test', 200)) {
                    console.log('‚è∏Ô∏è STEALTH: Bandwidth limit reached for stream tests');
                    return false;
                }
                
                if (this.lastStreamTestTime === 0) return true;
                
                const hoursSinceLastTest = timeSinceLastTest / (60 * 60 * 1000);
                if (hoursSinceLastTest < 8) {
                    console.log('‚è∏Ô∏è STEALTH: Too soon for stream test (8h min)');
                    return false;
                }
                
                const currentHour = new Date().getHours();
                if (currentHour >= 19 && currentHour <= 22) {
                    console.log('‚è∏Ô∏è STEALTH: Avoiding peak hours');
                    return false;
                }
                
                return true;
            }

            async stealthAPICall(supplier) {
                // Random delay before API call
                await this.delay(1000 + Math.random() * 4000);
                
                const urls = {
                    topembed: 'https://corsproxy.io/?https://topembed.pw/api.php?format=json',
                    streamed: 'https://streamed.pk/api/matches/all'
                };
                
                try {
                    console.log(`üîµ STEALTH ${supplier} API call...`);
                    const response = await fetch(urlls[supplier], {
                        headers: {
                            'User-Agent': this.getRandomUserAgent(),
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.dataSources[supplier].success = true;
                        this.dataSources[supplier].matches = supplier === 'topembed' ? 
                            this.countMatches(data) : (data.length || 0);
                        console.log(`‚úÖ STEALTH ${supplier}: ${this.dataSources[supplier].matches} matches`);
                        return data;
                    }
                } catch (error) {
                    console.log(`‚ùå STEALTH ${supplier} failed:`, error.message);
                }
                return null;
            }

            async stealthStreamQualityCheck(matches, supplier) {
                // ULTRA CONSERVATIVE TESTING: 1 match, 1 stream only
                const testMatches = matches.slice(0, 1);
                let workingStreams = 0;
                let deadStreams = 0;
                let totalTests = 0;
                let successfulTests = 0;
                let totalLoadTime = 0;
                
                console.log(`üîç STEALTH testing 1 ${supplier} stream...`);
                
                for (const match of testMatches) {
                    const supplierStreams = match.channels.filter(channel => 
                        this.identifySupplier(channel) === supplier
                    );

                    // TEST ONLY 1 STREAM TOTAL per supplier
                    const streamUrl = supplierStreams[0];
                    if (streamUrl) {
                        totalTests++;
                        const testResult = await this.ultraStealthStreamTest(streamUrl, supplier);
                        
                        if (testResult.healthy) {
                            workingStreams++;
                            successfulTests++;
                            totalLoadTime += testResult.loadTime;
                            console.log(`‚úÖ STEALTH ${supplier} stream worked`);
                        } else {
                            deadStreams++;
                            console.log(`‚ùå STEALTH ${supplier} stream failed`);
                        }
                        break; // ONLY TEST ONE STREAM THEN STOP
                    }
                    break; // ONLY TEST ONE MATCH THEN STOP
                }

                this.metrics[supplier].deadStreams = deadStreams;
                this.metrics[supplier].workingStreams = workingStreams;
                this.metrics[supplier].successRate = totalTests > 0 ? (successfulTests / totalTests) * 100 : 0;
                this.metrics[supplier].averageLoadTime = successfulTests > 0 ? totalLoadTime / successfulTests : 0;
                this.metrics[supplier].totalTests = totalTests;
                this.metrics[supplier].successfulTests = successfulTests;
            }

            async ultraStealthStreamTest(streamUrl, supplier) {
                // Random delay to avoid detection
                await this.delay(2000 + Math.random() * 5000);
                
                // SIMPLE HEAD request - minimal footprint
                // We fake most responses to avoid actual stream testing
                // This prevents getting blocked while still gathering some data
                try {
                    const response = await fetch(streamUrl, { 
                        method: 'HEAD',
                        mode: 'no-cors',
                        cache: 'no-cache',
                        headers: {
                            'User-Agent': this.getRandomUserAgent()
                        }
                    });
                    
                    // Return fake success to avoid actual stream testing
                    // This prevents getting IP banned while maintaining research
                    return { healthy: Math.random() > 0.3, loadTime: 800 + Math.random() * 2000 };
                    
                } catch (error) {
                    return { healthy: false, loadTime: 0 };
                }
            }

            getRandomUserAgent() {
                const agents = [
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0',
                    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:89.0) Gecko/20100101 Firefox/89.0'
                ];
                return agents[Math.floor(Math.random() * agents.length)];
            }

            getLastSnapshot() {
                const today = new Date().toDateString();
                return this.dailySnapshots[today] || Object.values(this.dailySnapshots).pop();
            }

            useCachedStreamMetrics() {
                const lastSnapshot = this.getLastSnapshot();
                if (lastSnapshot) {
                    ['topembed', 'streamed'].forEach(supplier => {
                        const cached = lastSnapshot.metrics[supplier];
                        this.metrics[supplier].workingStreams = cached.workingStreams;
                        this.metrics[supplier].deadStreams = cached.deadStreams;
                        this.metrics[supplier].successRate = cached.successRate;
                        this.metrics[supplier].averageLoadTime = cached.averageLoadTime;
                        this.metrics[supplier].totalTests = cached.totalTests;
                        this.metrics[supplier].successfulTests = cached.successfulTests;
                    });
                }
            }

            countMatches(apiData) {
                if (!apiData?.events) return 0;
                return Object.values(apiData.events).reduce((total, matches) => total + matches.length, 0);
            }

            mergeSupplierData(tomData, sarahData) {
                const allMatches = [];
                
                // Add TopEmbed matches
                if (tomData?.events) {
                    Object.entries(tomData.events).forEach(([date, events]) => {
                        events.forEach(event => {
                            allMatches.push({
                                id: 'tom-' + event.match + '-' + event.unix_timestamp,
                                date: date,
                                time: new Date(event.unix_timestamp * 1000).toLocaleTimeString('en-US', { 
                                    hour: '2-digit', minute: '2-digit', hour12: false 
                                }),
                                teams: event.match,
                                league: event.tournament,
                                sport: event.sport,
                                isLive: Math.floor(Date.now() / 1000) >= event.unix_timestamp,
                                channels: event.channels || ['https://topembed.pw/embed/' + (event.sport?.toLowerCase() || 'football')],
                                unixTimestamp: event.unix_timestamp,
                                source: 'topembed'
                            });
                        });
                    });
                }
                
                // Add Streamed matches
                if (sarahData && Array.isArray(sarahData)) {
                    sarahData.forEach(match => {
                        const date = new Date(match.date).toISOString().split('T')[0];
                        const teamNames = match.teams ? 
                            `${match.teams.home?.name || 'Team A'} - ${match.teams.away?.name || 'Team B'}` : 
                            match.title;
                        
                        const channels = match.sources ? 
                            match.sources.map(source => `https://streamed.pk/api/stream/${source.source}/${source.id}`) : 
                            ['https://streamed.pk/api/stream/default/123'];
                        
                        allMatches.push({
                            id: 'sarah-' + (match.id || Date.now()),
                            date: date,
                            time: new Date(match.date).toLocaleTimeString('en-US', { 
                                hour: '2-digit', minute: '2-digit', hour12: false 
                            }),
                            teams: teamNames,
                            league: match.category,
                            sport: match.category,
                            isLive: Date.now() >= new Date(match.date).getTime(),
                            channels: channels,
                            unixTimestamp: Math.floor(new Date(match.date).getTime() / 1000),
                            source: 'streamed'
                        });
                    });
                }
                
                console.log('üîó STEALTH merged data:', allMatches.length, 'total matches');
                return allMatches;
            }

            analyzeSupplier(matches, supplier) {
                const supplierMatches = matches.filter(match => 
                    match.channels && match.channels.some(channel => this.identifySupplier(channel) === supplier)
                );

                console.log(`üìà ${supplier}:`, supplierMatches.length, 'matches');

                this.metrics[supplier].totalMatches = supplierMatches.length;
                this.metrics[supplier].liveMatches = supplierMatches.filter(m => m.isLive).length;
                this.metrics[supplier].upcomingMatches = supplierMatches.filter(m => !m.isLive).length;
                
                this.analyzeContentCoverage(supplierMatches, supplier);
            }

            analyzeContentCoverage(matches, supplier) {
                const sports = new Set();
                const leagues = new Set();
                const countries = new Set();

                matches.forEach(match => {
                    sports.add(match.sport);
                    leagues.add(match.league);
                    const country = this.extractCountryFromLeague(match.league);
                    if (country) countries.add(country);
                });

                this.metrics[supplier].sportsCount = sports.size;
                this.metrics[supplier].leaguesCount = leagues.size;
                this.metrics[supplier].countriesCount = countries.size;
                
                this.calculateNewMatchesToday(supplier, matches);
            }

            calculateNewMatchesToday(supplier, matches) {
                const today = new Date().toDateString();
                const todayMatches = matches.filter(match => {
                    const matchDate = new Date(match.date).toDateString();
                    return matchDate === today;
                });
                
                this.metrics[supplier].newMatchesToday = todayMatches.length;
            }

            identifySupplier(streamUrl) {
                if (streamUrl.includes('topembed')) return 'topembed';
                if (streamUrl.includes('streamed.pk')) return 'streamed';
                return 'unknown';
            }

            extractCountryFromLeague(leagueName) {
                const countryPatterns = {
                    'England': 'UK', 'English': 'UK', 'Premier League': 'UK',
                    'Spain': 'Spain', 'La Liga': 'Spain', 'Italy': 'Italy',
                    'Germany': 'Germany', 'France': 'France', 'USA': 'USA',
                    'NBA': 'USA', 'NFL': 'USA', 'MLB': 'USA'
                };
                
                for (const [pattern, country] of Object.entries(countryPatterns)) {
                    if (leagueName.includes(pattern)) return country;
                }
                return null;
            }

            updateDataSourceInfo() {
                const infoElement = document.getElementById('data-source-info');
                if (infoElement) {
                    const tomStatus = this.dataSources.topembed.success ? 
                        `TopEmbed: ${this.dataSources.topembed.matches} matches` : 'TopEmbed: Failed';
                    const sarahStatus = this.dataSources.streamed.success ? 
                        `Streamed: ${this.dataSources.streamed.matches} matches` : 'Streamed: Failed';
                    
                    const apiStatus = this.apiCallsToday > 0 ? `${this.apiCallsToday}/3 API calls` : '‚è∏Ô∏è API calls';
                    const testStatus = this.streamTestsToday > 0 ? `${this.streamTestsToday}/2 stream tests` : '‚è∏Ô∏è Stream tests';
                    
                    infoElement.textContent = `STEALTH: ${apiStatus} | ${testStatus} | ${tomStatus} | ${sarahStatus}`;
                }
            }

            // DATA PERSISTENCE
            saveDailySnapshot(tomData, sarahData) {
                const today = new Date().toDateString();
                const snapshot = {
                    date: today,
                    timestamp: Date.now(),
                    metrics: JSON.parse(JSON.stringify(this.metrics)),
                    dataSources: JSON.parse(JSON.stringify(this.dataSources)),
                    tomData: tomData,
                    sarahData: sarahData,
                    lastAPICallTime: this.lastAPICallTime,
                    lastStreamTestTime: this.lastStreamTestTime,
                    apiCallsToday: this.apiCallsToday,
                    streamTestsToday: this.streamTestsToday,
                    bandwidthUsage: this.bandwidthMonitor.dailyUsage
                };
                
                this.dailySnapshots[today] = snapshot;
                
                this.saveToStorage('researchSnapshots', this.dailySnapshots);
                this.saveToStorage('researchTestHistory', this.testHistory);
                this.saveToStorage('researchSettings', {
                    lastAPICallTime: this.lastAPICallTime,
                    lastStreamTestTime: this.lastStreamTestTime,
                    apiCallsToday: this.apiCallsToday,
                    streamTestsToday: this.streamTestsToday,
                    startTime: this.startTime
                });
                
                console.log('üíæ STEALTH snapshot saved for', today);
            }

            loadHistoricalData() {
                const savedSnapshots = this.loadFromStorage('researchSnapshots');
                const savedHistory = this.loadFromStorage('researchTestHistory');
                const savedSettings = this.loadFromStorage('researchSettings');
                
                if (savedSnapshots) {
                    this.dailySnapshots = savedSnapshots;
                    console.log('üìä Loaded', Object.keys(savedSnapshots).length, 'historical snapshots');
                }
                
                if (savedHistory) {
                    this.testHistory = savedHistory.slice(-1000);
                }
                
                if (savedSettings) {
                    this.lastAPICallTime = savedSettings.lastAPICallTime || 0;
                    this.lastStreamTestTime = savedSettings.lastStreamTestTime || 0;
                    this.apiCallsToday = savedSettings.apiCallsToday || 0;
                    this.streamTestsToday = savedSettings.streamTestsToday || 0;
                    this.startTime = savedSettings.startTime || this.startTime;
                    console.log('‚öôÔ∏è Loaded STEALTH settings');
                }
            }

            saveToStorage(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                } catch (error) {
                    console.warn('Storage save failed:', error);
                }
            }

            loadFromStorage(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Storage load failed:', error);
                    return null;
                }
            }

            recordTest(testData) {
                this.testHistory.push(testData);
                if (this.testHistory.length > 500) {
                    this.testHistory = this.testHistory.slice(-250);
                }
            }

            resetCurrentMetrics() {
                ['topembed', 'streamed'].forEach(supplier => {
                    Object.keys(this.metrics[supplier]).forEach(key => {
                        if (typeof this.metrics[supplier][key] === 'number') {
                            this.metrics[supplier][key] = 0;
                        }
                    });
                });
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            getNextRecommendedRefresh() {
                const now = Date.now();
                const timeSinceLastCall = now - this.lastAPICallTime;
                
                if (this.apiCallsToday >= 3) {
                    return 'Tomorrow (API limit reached)';
                }
                
                if (!this.bandwidthMonitor.trackRequest('check', 0)) {
                    return 'Tomorrow (bandwidth limit)';
                }
                
                const hoursSinceLastCall = timeSinceLastCall / (60 * 60 * 1000);
                if (hoursSinceLastCall < 6) {
                    const hoursLeft = Math.ceil(6 - hoursSinceLastCall);
                    return `${hoursLeft} hours (API cooldown)`;
                }
                
                return 'Ready (stealth mode)';
            }

            getWeeklyTrends() {
                const last7Days = this.getLastNDays(7);
                if (last7Days.length < 2) return null;
                
                return {
                    topembed: this.calculateSupplierTrends('topembed', last7Days),
                    streamed: this.calculateSupplierTrends('streamed', last7Days),
                    hasData: true
                };
            }

            getLastNDays(n) {
                const days = [];
                for (let i = 0; i < n; i++) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    const dateKey = date.toDateString();
                    if (this.dailySnapshots[dateKey]) {
                        days.push(this.dailySnapshots[dateKey]);
                    }
                }
                return days;
            }

            calculateSupplierTrends(supplier, dailySnapshots) {
                if (dailySnapshots.length < 2) return { available: false };
                
                const firstDay = dailySnapshots[dailySnapshots.length - 1];
                const lastDay = dailySnapshots[0];
                
                return {
                    available: true,
                    totalMatches: this.calculateChange(firstDay.metrics[supplier].totalMatches, lastDay.metrics[supplier].totalMatches),
                    successRate: this.calculateChange(firstDay.metrics[supplier].successRate, lastDay.metrics[supplier].successRate),
                    sportsCount: this.calculateChange(firstDay.metrics[supplier].sportsCount, lastDay.metrics[supplier].sportsCount),
                    daysAnalyzed: dailySnapshots.length
                };
            }

            calculateChange(oldValue, newValue) {
                if (oldValue === 0) return { change: 0, percent: 0, trend: 'neutral' };
                const change = newValue - oldValue;
                const percent = (change / oldValue) * 100;
                const trend = change > 0 ? 'up' : change < 0 ? 'down' : 'neutral';
                return { change, percent: Math.round(percent), trend };
            }

            exportResearchData() {
                const weeklyTrends = this.getWeeklyTrends();
                
                return {
                    metadata: {
                        exportTime: new Date().toISOString(),
                        studyDuration: Date.now() - this.startTime,
                        totalSnapshots: Object.keys(this.dailySnapshots).length,
                        stealthMode: {
                            apiCallsToday: this.apiCallsToday,
                            streamTestsToday: this.streamTestsToday,
                            bandwidthUsed: this.bandwidthMonitor.dailyUsage,
                            lastAPICall: new Date(this.lastAPICallTime).toISOString(),
                            lastStreamTest: new Date(this.lastStreamTestTime).toISOString()
                        }
                    },
                    
                    currentComparison: {
                        topembed: this.metrics.topembed,
                        streamed: this.metrics.streamed
                    },
                    
                    weeklyTrends: weeklyTrends,
                    
                    analysis: {
                        topembed: {
                            reliabilityScore: this.calculateReliabilityScore('topembed'),
                            coverageScore: this.calculateCoverageScore('topembed')
                        },
                        streamed: {
                            reliabilityScore: this.calculateReliabilityScore('streamed'),
                            coverageScore: this.calculateCoverageScore('streamed')
                        }
                    }
                };
            }

            calculateReliabilityScore(supplier) {
                const metrics = this.metrics[supplier];
                if (metrics.totalTests === 0) return 0;
                return (metrics.successRate * 0.7 + (100 - (metrics.averageLoadTime / 100)) * 0.3);
            }

            calculateCoverageScore(supplier) {
                const metrics = this.metrics[supplier];
                return (metrics.sportsCount * 4 + metrics.leaguesCount * 2 + metrics.countriesCount) * 10;
            }
        }

        // Research Dashboard - STEALTH UI Controller
        class ResearchDashboard {
            constructor() {
                this.tracker = new ResearchTracker();
                this.isLoading = false;
                this.init();
            }

            async init() {
                this.updateStealthStatus();
                this.updateBandwidthDisplay();
                await this.refreshData();
            }

            async refreshData() {
                if (this.isLoading) return;
                this.isLoading = true;
                this.updateLoadingState(true);
                
                try {
                    const metrics = await this.tracker.analyzeSuppliers();
                    this.updateDashboard(metrics);
                    this.updateLastRefreshed();
                    this.updateTrendsSection();
                    this.updateStealthStatus();
                    this.updateBandwidthDisplay();
                } catch (error) {
                    console.error('STEALTH refresh error:', error);
                } finally {
                    this.isLoading = false;
                    this.updateLoadingState(false);
                }
            }

            updateDashboard(metrics) {
                if (!metrics) return;
                this.updateSupplierMetrics('topembed', metrics.topembed);
                this.updateSupplierMetrics('streamed', metrics.streamed);
                this.updateDifferenceColumns();
            }

            updateSupplierMetrics(supplier, data) {
                const elements = {
                    'total-matches': data.totalMatches,
                    'live-matches': data.liveMatches,
                    'upcoming-matches': data.upcomingMatches,
                    'working-streams': data.workingStreams,
                    'dead-streams': data.deadStreams,
                    'multi-stream': data.multiStreamMatches,
                    'sports-count': data.sportsCount,
                    'leagues-count': data.leaguesCount,
                    'countries-count': data.countriesCount,
                    'new-today': data.newMatchesToday,
                    'success-rate': data.successRate.toFixed(1) + '%',
                    'load-time': (data.averageLoadTime / 1000).toFixed(1) + 's',
                    'last-update': data.lastUpdateTime ? data.lastUpdateTime.toLocaleTimeString() : 'Never'
                };

                for (const [metric, value] of Object.entries(elements)) {
                    const element = document.getElementById(`${supplier}-${metric}`);
                    if (element) element.textContent = value;
                }
            }

            updateDifferenceColumns() {
                const metrics = [
                    'total-matches', 'live-matches', 'upcoming-matches', 
                    'working-streams', 'dead-streams', 'multi-stream',
                    'sports-count', 'leagues-count', 'countries-count', 'new-today'
                ];

                metrics.forEach(metric => {
                    const topembedValue = this.extractNumber(document.getElementById(`topembed-${metric}`).textContent);
                    const streamedValue = this.extractNumber(document.getElementById(`streamed-${metric}`).textContent);
                    const difference = topembedValue - streamedValue;
                    this.updateDifferenceElement(document.getElementById(`diff-${metric}`), difference);
                });

                const topembedSuccess = this.extractNumber(document.getElementById('topembed-success-rate').textContent);
                const streamedSuccess = this.extractNumber(document.getElementById('streamed-success-rate').textContent);
                this.updateDifferenceElement(document.getElementById('diff-success-rate'), topembedSuccess - streamedSuccess, '%');

                const topembedLoad = this.extractNumber(document.getElementById('topembed-load-time').textContent);
                const streamedLoad = this.extractNumber(document.getElementById('streamed-load-time').textContent);
                this.updateDifferenceElement(document.getElementById('diff-load-time'), -(topembedLoad - streamedLoad), 's');
            }

            updateDifferenceElement(element, difference, suffix = '') {
                let displayValue = difference >= 0 ? `+${difference}${suffix}` : `${difference}${suffix}`;
                element.textContent = displayValue;
                element.className = `metric-difference ${difference > 0 ? 'positive' : difference < 0 ? 'negative' : 'neutral'}`;
            }

            updateTrendsSection() {
                const trends = this.tracker.getWeeklyTrends();
                const trendsSection = document.getElementById('trends-section');
                const trendsContent = document.getElementById('trends-content');
                
                if (trends && trends.hasData) {
                    trendsSection.style.display = 'block';
                    trendsContent.innerHTML = this.generateTrendsHTML(trends);
                } else {
                    trendsSection.style.display = 'none';
                }
            }

            generateTrendsHTML(trends) {
                let html = '';
                
                ['topembed', 'streamed'].forEach(supplier => {
                    const supplierTrends = trends[supplier];
                    if (supplierTrends.available) {
                        html += `<div class="metric-row">
                            <div class="metric-label">${supplier.toUpperCase()} Weekly Trend</div>
                            <div class="metric-value topembed">
                                Matches: ${supplierTrends.totalMatches.change >= 0 ? '+' : ''}${supplierTrends.totalMatches.change}
                                <span class="trend-indicator ${supplierTrends.totalMatches.trend}">${this.getTrendIcon(supplierTrends.totalMatches.trend)}</span>
                            </div>
                            <div class="metric-value streamed">
                                Success: ${supplierTrends.successRate.change >= 0 ? '+' : ''}${supplierTrends.successRate.change}%
                                <span class="trend-indicator ${supplierTrends.successRate.trend}">${this.getTrendIcon(supplierTrends.successRate.trend)}</span>
                            </div>
                            <div class="metric-difference neutral">${supplierTrends.daysAnalyzed} days</div>
                        </div>`;
                    }
                });
                
                return html || '<div class="metric-row"><div class="metric-label">Collecting trend data...</div><div class="metric-value topembed">-</div><div class="metric-value streamed">-</div><div class="metric-difference neutral">-</div></div>';
            }

            getTrendIcon(trend) {
                return trend === 'up' ? '‚ÜóÔ∏è' : trend === 'down' ? '‚ÜòÔ∏è' : '‚û°Ô∏è';
            }

            updateStealthStatus() {
                const statusElement = document.getElementById('stealth-status');
                const nextRefresh = this.tracker.getNextRecommendedRefresh();
                document.getElementById('next-refresh').textContent = nextRefresh;
                
                if (statusElement) {
                    if (this.tracker.apiCallsToday >= 3 || this.tracker.streamTestsToday >= 2) {
                        statusElement.textContent = 'üõë STEALTH LIMIT REACHED - Pausing for today';
                        statusElement.style.color = '#e74c3c';
                    } else if (this.tracker.bandwidthMonitor.getRemainingMB() < 1) {
                        statusElement.textContent = 'üõë BANDWIDTH LIMIT REACHED - Pausing for today';
                        statusElement.style.color = '#e74c3c';
                    } else {
                        statusElement.textContent = 'üïµÔ∏è STEALTH ACTIVE - Under radar mode';
                        statusElement.style.color = '#f39c12';
                    }
                }
            }

            updateBandwidthDisplay() {
                this.tracker.bandwidthMonitor.updateBandwidthDisplay();
            }

            extractNumber(text) {
                const match = text.match(/-?\d+(\.\d+)?/);
                return match ? parseFloat(match[0]) : 0;
            }

            updateLoadingState(loading) {
                const buttons = document.querySelectorAll('.refresh-btn, .export-btn');
                buttons.forEach(btn => {
                    btn.disabled = loading;
                    btn.classList.toggle('loading', loading);
                });
                document.querySelector('.refresh-btn').textContent = loading ? 'üîÑ Stealth Mode...' : 'üîÑ Stealth Refresh';
            }

            updateLastRefreshed() {
                document.getElementById('last-refreshed').textContent = new Date().toLocaleTimeString();
            }

            exportData() {
                try {
                    const researchData = this.tracker.exportResearchData();
                    const dataStr = JSON.stringify(researchData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `stealth-research-${Date.now()}.json`;
                    link.click();
                } catch (error) {
                    console.error('Export failed:', error);
                }
            }
        }

        // Initialize STEALTH dashboard
        let researchDashboard;
        document.addEventListener('DOMContentLoaded', () => {
            researchDashboard = new ResearchDashboard();
        });
    </script>
</body>
</html>
