<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supplier Research Dashboard - 9kilos</title>
    <style>
        /* [KEEP ALL THE EXISTING CSS STYLES - THEY ARE THE SAME] */
        :root {
            --primary-bg: linear-gradient(135deg, #0a0a1a 0%, #0f3460 50%, #1a1a2e 100%);
            --header-bg: rgba(15, 52, 96, 0.95);
            --card-bg: rgba(255, 255, 255, 0.08);
            --accent-gold: #ffd93d;
            --accent-blue: #3498db;
            --text-primary: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.6);
            --border-light: rgba(255, 255, 255, 0.1);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .research-dashboard {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .dashboard-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: var(--header-bg);
            border-radius: 16px;
            border: 1px solid var(--border-light);
        }
        
        .dashboard-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcf7f, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .dashboard-header p {
            color: var(--text-muted);
            font-size: 1.1em;
        }
        
        .supplier-comparison {
            display: grid;
            gap: 25px;
        }
        
        .comparison-header {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 15px;
            font-weight: bold;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-light);
            font-size: 1.1em;
        }
        
        .metric-section {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid var(--border-light);
        }
        
        .metric-section h3 {
            margin: 0 0 20px 0;
            color: var(--accent-gold);
            font-size: 1.3em;
        }
        
        .metric-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 15px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-light);
            align-items: center;
        }
        
        .metric-row:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .metric-value {
            text-align: center;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .topembed { 
            background: rgba(52, 152, 219, 0.1);
            color: #3498db;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .streamed { 
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        
        .metric-difference {
            text-align: center;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .positive {
            background: rgba(39, 174, 96, 0.1);
            color: #27ae60;
            border: 1px solid rgba(39, 174, 96, 0.3);
        }
        
        .negative {
            background: rgba(192, 57, 43, 0.1);
            color: #c0392b;
            border: 1px solid rgba(192, 57, 43, 0.3);
        }
        
        .neutral {
            background: rgba(149, 165, 166, 0.1);
            color: #95a5a6;
            border: 1px solid rgba(149, 165, 166, 0.3);
        }
        
        .supplier-name.topembed { color: #3498db; }
        .supplier-name.streamed { color: #e74c3c; }
        
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        .refresh-btn, .export-btn {
            background: var(--accent-gold);
            color: black;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        
        .refresh-btn:hover, .export-btn:hover {
            transform: translateY(-2px);
        }
        
        .export-btn {
            background: var(--accent-blue);
            color: white;
        }
        
        .last-updated {
            text-align: center;
            color: var(--text-muted);
            margin-top: 20px;
            font-size: 0.9em;
        }
        
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .data-source {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8em;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="research-dashboard">
        <div class="dashboard-header">
            <h1>ðŸ”¬ Supplier Research Dashboard</h1>
            <p>Real-time analytics comparing TopEmbed.pw vs Streamed.pk</p>
            <div class="data-source" id="data-source-info">Loading data from both APIs...</div>
        </div>
        
        <div class="controls">
            <button class="refresh-btn" onclick="researchDashboard.refreshData()">ðŸ”„ Refresh Data</button>
            <button class="export-btn" onclick="researchDashboard.exportData()">ðŸ’¾ Export Research Data</button>
        </div>

        <div class="supplier-comparison">
            
            <!-- HEADER ROW -->
            <div class="comparison-header">
                <div class="supplier-name">METRIC</div>
                <div class="supplier-name topembed">TOPEMBED.PW</div>
                <div class="supplier-name streamed">STREAMED.PK</div>
                <div class="supplier-name">DIFFERENCE</div>
            </div>

            <!-- CONTENT VOLUME SECTION -->
            <div class="metric-section">
                <h3>ðŸ“Š Content Volume</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Total Matches</div>
                    <div class="metric-value topembed" id="topembed-total-matches">0</div>
                    <div class="metric-value streamed" id="streamed-total-matches">0</div>
                    <div class="metric-difference neutral" id="diff-total-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Live Matches</div>
                    <div class="metric-value topembed" id="topembed-live-matches">0</div>
                    <div class="metric-value streamed" id="streamed-live-matches">0</div>
                    <div class="metric-difference neutral" id="diff-live-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Upcoming Matches</div>
                    <div class="metric-value topembed" id="topembed-upcoming-matches">0</div>
                    <div class="metric-value streamed" id="streamed-upcoming-matches">0</div>
                    <div class="metric-difference neutral" id="diff-upcoming-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Working Streams</div>
                    <div class="metric-value topembed" id="topembed-working-streams">0</div>
                    <div class="metric-value streamed" id="streamed-working-streams">0</div>
                    <div class="metric-difference neutral" id="diff-working-streams">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Dead Streams</div>
                    <div class="metric-value topembed" id="topembed-dead-streams">0</div>
                    <div class="metric-value streamed" id="streamed-dead-streams">0</div>
                    <div class="metric-difference neutral" id="diff-dead-streams">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Multi-Stream Matches</div>
                    <div class="metric-value topembed" id="topembed-multi-stream">0</div>
                    <div class="metric-value streamed" id="streamed-multi-stream">0</div>
                    <div class="metric-difference neutral" id="diff-multi-stream">0</div>
                </div>
            </div>

            <!-- CONTENT COVERAGE SECTION -->
            <div class="metric-section">
                <h3>ðŸŽ¯ Content Coverage</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Sports Categories</div>
                    <div class="metric-value topembed" id="topembed-sports-count">0</div>
                    <div class="metric-value streamed" id="streamed-sports-count">0</div>
                    <div class="metric-difference neutral" id="diff-sports-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Different Leagues</div>
                    <div class="metric-value topembed" id="topembed-leagues-count">0</div>
                    <div class="metric-value streamed" id="streamed-leagues-count">0</div>
                    <div class="metric-difference neutral" id="diff-leagues-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Countries Covered</div>
                    <div class="metric-value topembed" id="topembed-countries-count">0</div>
                    <div class="metric-value streamed" id="streamed-countries-count">0</div>
                    <div class="metric-difference neutral" id="diff-countries-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">New Matches Today</div>
                    <div class="metric-value topembed" id="topembed-new-today">0</div>
                    <div class="metric-value streamed" id="streamed-new-today">0</div>
                    <div class="metric-difference neutral" id="diff-new-today">0</div>
                </div>
            </div>

            <!-- PERFORMANCE SECTION -->
            <div class="metric-section">
                <h3>âš¡ Performance & Reliability</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Stream Success Rate</div>
                    <div class="metric-value topembed" id="topembed-success-rate">0%</div>
                    <div class="metric-value streamed" id="streamed-success-rate">0%</div>
                    <div class="metric-difference neutral" id="diff-success-rate">0%</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Average Load Time</div>
                    <div class="metric-value topembed" id="topembed-load-time">0s</div>
                    <div class="metric-value streamed" id="streamed-load-time">0s</div>
                    <div class="metric-difference neutral" id="diff-load-time">0s</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Last Data Update</div>
                    <div class="metric-value topembed" id="topembed-last-update">Never</div>
                    <div class="metric-value streamed" id="streamed-last-update">Never</div>
                    <div class="metric-difference neutral">-</div>
                </div>
            </div>

        </div>

        <div class="last-updated">
            Last refreshed: <span id="last-refreshed">Never</span>
        </div>
    </div>

    <script>
        // Research Tracker - Data Analysis
        class ResearchTracker {
            constructor() {
                this.metrics = {
                    topembed: this.createSupplierMetrics(),
                    streamed: this.createSupplierMetrics()
                };
                this.testHistory = [];
                this.dailySnapshots = {};
                this.startTime = Date.now();
                this.dataSources = {
                    topembed: { success: false, matches: 0 },
                    streamed: { success: false, matches: 0 }
                };
            }

            createSupplierMetrics() {
                return {
                    totalMatches: 0,
                    liveMatches: 0,
                    upcomingMatches: 0,
                    deadStreams: 0,
                    workingStreams: 0,
                    multiStreamMatches: 0,
                    sportsCount: 0,
                    leaguesCount: 0,
                    countriesCount: 0,
                    newMatchesToday: 0,
                    successRate: 0,
                    averageLoadTime: 0,
                    totalTests: 0,
                    successfulTests: 0,
                    lastUpdateTime: null
                };
            }

            async analyzeSuppliers() {
                console.log('ðŸ”„ Fetching data from both suppliers...');
                this.resetCurrentMetrics();
                
                // Get data from BOTH suppliers
                const [tomData, sarahData] = await Promise.all([
                    this.fetchTopEmbedData(),
                    this.fetchStreamedData()
                ]);
                
                console.log('ðŸ“Š Data received:', {
                    tom: tomData ? 'âœ…' : 'âŒ',
                    sarah: sarahData ? 'âœ…' : 'âŒ'
                });
                
                // Convert and merge data from both sources
                const allMatches = this.mergeSupplierData(tomData, sarahData);
                
                if (allMatches.length === 0) {
                    console.warn('No matches available from either supplier');
                    return this.metrics;
                }

                // Analyze each supplier separately
                this.analyzeSupplier(allMatches, 'topembed');
                this.analyzeSupplier(allMatches, 'streamed');
                
                const now = new Date();
                this.metrics.topembed.lastUpdateTime = now;
                this.metrics.streamed.lastUpdateTime = now;
                
                // Update data source info
                this.updateDataSourceInfo();
                
                return this.metrics;
            }

            async fetchTopEmbedData() {
                try {
                    console.log('ðŸ”µ Fetching TopEmbed data...');
                    const response = await fetch('https://corsproxy.io/?https://topembed.pw/api.php?format=json');
                    if (response.ok) {
                        const data = await response.json();
                        this.dataSources.topembed.success = true;
                        this.dataSources.topembed.matches = this.countMatches(data);
                        console.log('âœ… TopEmbed:', this.dataSources.topembed.matches, 'matches');
                        return data;
                    }
                } catch (error) {
                    console.log('âŒ TopEmbed failed:', error.message);
                }
                return null;
            }

            async fetchStreamedData() {
                try {
                    console.log('ðŸ”´ Fetching Streamed data...');
                    const response = await fetch('https://streamed.pk/api/matches/all');
                    if (response.ok) {
                        const data = await response.json();
                        this.dataSources.streamed.success = true;
                        this.dataSources.streamed.matches = data.length || 0;
                        console.log('âœ… Streamed:', this.dataSources.streamed.matches, 'matches');
                        return data;
                    }
                } catch (error) {
                    console.log('âŒ Streamed failed:', error.message);
                }
                return null;
            }

            countMatches(apiData) {
                if (!apiData?.events) return 0;
                return Object.values(apiData.events).reduce((total, matches) => total + matches.length, 0);
            }

            mergeSupplierData(tomData, sarahData) {
                const allMatches = [];
                
                // Add TopEmbed matches
                if (tomData?.events) {
                    Object.entries(tomData.events).forEach(([date, events]) => {
                        events.forEach(event => {
                            allMatches.push({
                                id: 'tom-' + event.match + '-' + event.unix_timestamp,
                                date: date,
                                time: new Date(event.unix_timestamp * 1000).toLocaleTimeString('en-US', { 
                                    hour: '2-digit', minute: '2-digit', hour12: false 
                                }),
                                teams: event.match,
                                league: event.tournament,
                                sport: event.sport,
                                isLive: Math.floor(Date.now() / 1000) >= event.unix_timestamp,
                                channels: event.channels || ['https://topembed.pw/embed/' + event.sport?.toLowerCase()],
                                unixTimestamp: event.unix_timestamp,
                                source: 'topembed'
                            });
                        });
                    });
                }
                
                // Add Streamed matches
                if (sarahData && Array.isArray(sarahData)) {
                    sarahData.forEach(match => {
                        const date = new Date(match.date).toISOString().split('T')[0];
                        const teamNames = match.teams ? 
                            `${match.teams.home?.name || 'Team A'} - ${match.teams.away?.name || 'Team B'}` : 
                            match.title;
                        
                        const channels = match.sources ? 
                            match.sources.map(source => `https://streamed.pk/api/stream/${source.source}/${source.id}`) : 
                            ['https://streamed.pk/api/stream/default/123'];
                        
                        allMatches.push({
                            id: 'sarah-' + match.id,
                            date: date,
                            time: new Date(match.date).toLocaleTimeString('en-US', { 
                                hour: '2-digit', minute: '2-digit', hour12: false 
                            }),
                            teams: teamNames,
                            league: match.category,
                            sport: match.category,
                            isLive: Date.now() >= new Date(match.date).getTime(),
                            channels: channels,
                            unixTimestamp: Math.floor(new Date(match.date).getTime() / 1000),
                            source: 'streamed'
                        });
                    });
                }
                
                console.log('ðŸ”— Merged data:', allMatches.length, 'total matches');
                return allMatches;
            }

            analyzeSupplier(matches, supplier) {
                const supplierMatches = matches.filter(match => 
                    match.channels && match.channels.some(channel => this.identifySupplier(channel) === supplier)
                );

                console.log(`ðŸ“ˆ ${supplier}:`, supplierMatches.length, 'matches');

                this.metrics[supplier].totalMatches = supplierMatches.length;
                this.metrics[supplier].liveMatches = supplierMatches.filter(m => m.isLive).length;
                this.metrics[supplier].upcomingMatches = supplierMatches.filter(m => !m.isLive).length;
                
                this.analyzeContentCoverage(supplierMatches, supplier);
                this.analyzeStreamQuality(supplierMatches, supplier);
            }

            analyzeContentCoverage(matches, supplier) {
                const sports = new Set();
                const leagues = new Set();
                const countries = new Set();

                matches.forEach(match => {
                    sports.add(match.sport);
                    leagues.add(match.league);
                    const country = this.extractCountryFromLeague(match.league);
                    if (country) countries.add(country);
                });

                this.metrics[supplier].sportsCount = sports.size;
                this.metrics[supplier].leaguesCount = leagues.size;
                this.metrics[supplier].countriesCount = countries.size;
            }

            async analyzeStreamQuality(matches, supplier) {
                let deadStreams = 0;
                let workingStreams = 0;
                let multiStreamMatches = 0;
                let totalLoadTime = 0;
                let successfulTests = 0;
                let totalTests = 0;

                // Test up to 15 matches to get good sample
                const testMatches = matches.slice(0, 15);
                
                for (const match of testMatches) {
                    const supplierStreams = match.channels.filter(channel => 
                        this.identifySupplier(channel) === supplier
                    );

                    if (supplierStreams.length > 1) multiStreamMatches++;

                    // Test up to 2 streams per match
                    for (const streamUrl of supplierStreams.slice(0, 2)) {
                        totalTests++;
                        const testResult = await this.testStreamHealth(streamUrl, supplier);
                        
                        if (testResult.healthy) {
                            workingStreams++;
                            successfulTests++;
                            totalLoadTime += testResult.loadTime;
                        } else {
                            deadStreams++;
                        }
                        await this.delay(200); // Shorter delay for faster testing
                    }
                }

                this.metrics[supplier].deadStreams = deadStreams;
                this.metrics[supplier].workingStreams = workingStreams;
                this.metrics[supplier].multiStreamMatches = multiStreamMatches;
                this.metrics[supplier].successRate = totalTests > 0 ? (successfulTests / totalTests) * 100 : 0;
                this.metrics[supplier].averageLoadTime = successfulTests > 0 ? totalLoadTime / successfulTests : 0;
                this.metrics[supplier].totalTests = totalTests;
                this.metrics[supplier].successfulTests = successfulTests;
            }

            async testStreamHealth(streamUrl, supplier) {
                const startTime = Date.now();
                
                try {
                    // Use no-cors to avoid CORS issues
                    await fetch(streamUrl, { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        cache: 'no-cache'
                    });
                    const loadTime = Date.now() - startTime;
                    
                    this.recordTest({
                        supplier,
                        streamUrl,
                        healthy: true,
                        loadTime,
                        timestamp: new Date().toISOString()
                    });
                    
                    return { healthy: true, loadTime };
                    
                } catch (error) {
                    this.recordTest({
                        supplier,
                        streamUrl, 
                        healthy: false,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    });
                    
                    return { healthy: false, loadTime: 0 };
                }
            }

            identifySupplier(streamUrl) {
                if (streamUrl.includes('topembed')) return 'topembed';
                if (streamUrl.includes('streamed.pk')) return 'streamed';
                return 'unknown';
            }

            extractCountryFromLeague(leagueName) {
                const countryPatterns = {
                    'England': 'UK', 'English': 'UK', 'Premier League': 'UK',
                    'Spain': 'Spain', 'La Liga': 'Spain', 'Italy': 'Italy',
                    'Germany': 'Germany', 'France': 'France', 'USA': 'USA',
                    'NBA': 'USA', 'NFL': 'USA', 'MLB': 'USA'
                };
                
                for (const [pattern, country] of Object.entries(countryPatterns)) {
                    if (leagueName.includes(pattern)) return country;
                }
                return null;
            }

            updateDataSourceInfo() {
                const infoElement = document.getElementById('data-source-info');
                if (infoElement) {
                    const tomStatus = this.dataSources.topembed.success ? 
                        `TopEmbed: ${this.dataSources.topembed.matches} matches` : 'TopEmbed: Failed';
                    const sarahStatus = this.dataSources.streamed.success ? 
                        `Streamed: ${this.dataSources.streamed.matches} matches` : 'Streamed: Failed';
                    
                    infoElement.textContent = `Data sources: ${tomStatus} | ${sarahStatus}`;
                }
            }

            recordTest(testData) {
                this.testHistory.push(testData);
                if (this.testHistory.length > 500) {
                    this.testHistory = this.testHistory.slice(-250);
                }
            }

            resetCurrentMetrics() {
                ['topembed', 'streamed'].forEach(supplier => {
                    Object.keys(this.metrics[supplier]).forEach(key => {
                        if (typeof this.metrics[supplier][key] === 'number') {
                            this.metrics[supplier][key] = 0;
                        }
                    });
                });
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            exportResearchData() {
                return {
                    metadata: {
                        exportTime: new Date().toISOString(),
                        totalTests: this.testHistory.length,
                        dataSources: this.dataSources,
                        studyDuration: Date.now() - this.startTime
                    },
                    supplierComparison: {
                        topembed: this.metrics.topembed,
                        streamed: this.metrics.streamed
                    },
                    performanceAnalysis: {
                        topembed: {
                            reliabilityScore: this.calculateReliabilityScore('topembed'),
                            coverageScore: this.calculateCoverageScore('topembed')
                        },
                        streamed: {
                            reliabilityScore: this.calculateReliabilityScore('streamed'),
                            coverageScore: this.calculateCoverageScore('streamed')
                        }
                    },
                    sampleTestData: this.testHistory.slice(-50)
                };
            }

            calculateReliabilityScore(supplier) {
                const metrics = this.metrics[supplier];
                if (metrics.totalTests === 0) return 0;
                return (metrics.successRate * 0.7 + (100 - (metrics.averageLoadTime / 100)) * 0.3);
            }

            calculateCoverageScore(supplier) {
                const metrics = this.metrics[supplier];
                return (metrics.sportsCount * 4 + metrics.leaguesCount * 2 + metrics.countriesCount) * 10;
            }

            getMetrics() {
                return this.metrics;
            }
        }

        // Research Dashboard - UI Controller
        class ResearchDashboard {
            constructor() {
                this.tracker = new ResearchTracker();
                this.isLoading = false;
                this.init();
            }

            async init() {
                this.startAutoRefresh();
                await this.refreshData();
            }

            async refreshData() {
                if (this.isLoading) return;
                this.isLoading = true;
                this.updateLoadingState(true);
                
                try {
                    const metrics = await this.tracker.analyzeSuppliers();
                    this.updateDashboard(metrics);
                    this.updateLastRefreshed();
                } catch (error) {
                    console.error('Refresh error:', error);
                } finally {
                    this.isLoading = false;
                    this.updateLoadingState(false);
                }
            }

            updateDashboard(metrics) {
                if (!metrics) return;
                this.updateSupplierMetrics('topembed', metrics.topembed);
                this.updateSupplierMetrics('streamed', metrics.streamed);
                this.updateDifferenceColumns();
            }

            updateSupplierMetrics(supplier, data) {
                const elements = {
                    'total-matches': data.totalMatches,
                    'live-matches': data.liveMatches,
                    'upcoming-matches': data.upcomingMatches,
                    'working-streams': data.workingStreams,
                    'dead-streams': data.deadStreams,
                    'multi-stream': data.multiStreamMatches,
                    'sports-count': data.sportsCount,
                    'leagues-count': data.leaguesCount,
                    'countries-count': data.countriesCount,
                    'new-today': data.newMatchesToday,
                    'success-rate': data.successRate.toFixed(1) + '%',
                    'load-time': (data.averageLoadTime / 1000).toFixed(1) + 's',
                    'last-update': data.lastUpdateTime ? data.lastUpdateTime.toLocaleTimeString() : 'Never'
                };

                for (const [metric, value] of Object.entries(elements)) {
                    const element = document.getElementById(`${supplier}-${metric}`);
                    if (element) element.textContent = value;
                }
            }

            updateDifferenceColumns() {
                const metrics = [
                    'total-matches', 'live-matches', 'upcoming-matches', 
                    'working-streams', 'dead-streams', 'multi-stream',
                    'sports-count', 'leagues-count', 'countries-count', 'new-today'
                ];

                metrics.forEach(metric => {
                    const topembedValue = this.extractNumber(document.getElementById(`topembed-${metric}`).textContent);
                    const streamedValue = this.extractNumber(document.getElementById(`streamed-${metric}`).textContent);
                    const difference = topembedValue - streamedValue;
                    this.updateDifferenceElement(document.getElementById(`diff-${metric}`), difference);
                });

                // Handle special metrics
                const topembedSuccess = this.extractNumber(document.getElementById('topembed-success-rate').textContent);
                const streamedSuccess = this.extractNumber(document.getElementById('streamed-success-rate').textContent);
                this.updateDifferenceElement(document.getElementById('diff-success-rate'), topembedSuccess - streamedSuccess, '%');

                const topembedLoad = this.extractNumber(document.getElementById('topembed-load-time').textContent);
                const streamedLoad = this.extractNumber(document.getElementById('streamed-load-time').textContent);
                this.updateDifferenceElement(document.getElementById('diff-load-time'), -(topembedLoad - streamedLoad), 's');
            }

            updateDifferenceElement(element, difference, suffix = '') {
                let displayValue = difference >= 0 ? `+${difference}${suffix}` : `${difference}${suffix}`;
                element.textContent = displayValue;
                element.className = `metric-difference ${difference > 0 ? 'positive' : difference < 0 ? 'negative' : 'neutral'}`;
            }

            extractNumber(text) {
                const match = text.match(/-?\d+(\.\d+)?/);
                return match ? parseFloat(match[0]) : 0;
            }

            updateLoadingState(loading) {
                const buttons = document.querySelectorAll('.refresh-btn, .export-btn');
                buttons.forEach(btn => {
                    btn.disabled = loading;
                    btn.classList.toggle('loading', loading);
                });
                document.querySelector('.refresh-btn').textContent = loading ? 'ðŸ”„ Testing...' : 'ðŸ”„ Refresh Data';
            }

            updateLastRefreshed() {
                document.getElementById('last-refreshed').textContent = new Date().toLocaleTimeString();
            }

            startAutoRefresh() {
                setInterval(() => this.refreshData(), 3 * 60 * 1000); // 3 minutes
            }

            exportData() {
                try {
                    const researchData = this.tracker.exportResearchData();
                    const dataStr = JSON.stringify(researchData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `supplier-research-${Date.now()}.json`;
                    link.click();
                } catch (error) {
                    console.error('Export failed:', error);
                }
            }
        }

        // Initialize dashboard
        let researchDashboard;
        document.addEventListener('DOMContentLoaded', () => {
            researchDashboard = new ResearchDashboard();
        });
    </script>
</body>
</html>
