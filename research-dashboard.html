<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supplier Research Dashboard - 9kilos</title>
    <style>
        :root {
            --primary-bg: linear-gradient(135deg, #0a0a1a 0%, #0f3460 50%, #1a1a2e 100%);
            --header-bg: rgba(15, 52, 96, 0.95);
            --card-bg: rgba(255, 255, 255, 0.08);
            --accent-gold: #ffd93d;
            --accent-blue: #3498db;
            --accent-purple: #9b59b6;
            --text-primary: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.6);
            --border-light: rgba(255, 255, 255, 0.1);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .research-dashboard {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .dashboard-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: var(--header-bg);
            border-radius: 16px;
            border: 1px solid var(--border-light);
        }
        
        .dashboard-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcf7f, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .dashboard-header p {
            color: var(--text-muted);
            font-size: 1.1em;
        }
        
        .supplier-comparison {
            display: grid;
            gap: 25px;
        }
        
        .comparison-header {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr 1fr;
            gap: 15px;
            font-weight: bold;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-light);
            font-size: 1.1em;
        }
        
        .metric-section {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid var(--border-light);
        }
        
        .metric-section h3 {
            margin: 0 0 20px 0;
            color: var(--accent-gold);
            font-size: 1.3em;
        }
        
        .metric-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr 1fr;
            gap: 15px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-light);
            align-items: center;
        }
        
        .metric-row:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .metric-value {
            text-align: center;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .topembed { 
            background: rgba(52, 152, 219, 0.1);
            color: #3498db;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .streamed { 
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        
        .emily { 
            background: rgba(155, 89, 182, 0.1);
            color: #9b59b6;
            border: 1px solid rgba(155, 89, 182, 0.3);
        }
        
        .metric-difference {
            text-align: center;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .positive {
            background: rgba(39, 174, 96, 0.1);
            color: #27ae60;
            border: 1px solid rgba(39, 174, 96, 0.3);
        }
        
        .negative {
            background: rgba(192, 57, 43, 0.1);
            color: #c0392b;
            border: 1px solid rgba(192, 57, 43, 0.3);
        }
        
        .neutral {
            background: rgba(149, 165, 166, 0.1);
            color: #95a5a6;
            border: 1px solid rgba(149, 165, 166, 0.3);
        }
        
        .supplier-name.topembed { color: #3498db; }
        .supplier-name.streamed { color: #e74c3c; }
        .supplier-name.emily { color: #9b59b6; }
        
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        .refresh-btn, .export-btn {
            background: var(--accent-gold);
            color: black;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        
        .refresh-btn:hover, .export-btn:hover {
            transform: translateY(-2px);
        }
        
        .export-btn {
            background: var(--accent-blue);
            color: white;
        }
        
        .last-updated {
            text-align: center;
            color: var(--text-muted);
            margin-top: 20px;
            font-size: 0.9em;
        }
        
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .data-source {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8em;
            margin-bottom: 10px;
        }
        
        .update-schedule {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.7em;
            margin-top: 5px;
        }
        
        .trend-indicator {
            font-size: 0.8em;
            margin-left: 5px;
        }
        
        .trend-up { color: #27ae60; }
        .trend-down { color: #e74c3c; }
        .trend-neutral { color: #95a5a6; }
        
        .stealth-status {
            text-align: center;
            color: #f39c12;
            font-size: 0.8em;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .bandwidth-meter {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.7em;
            margin-top: 5px;
        }

        /* API Monitoring Styles */
        .api-monitoring {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
        }

        .api-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .api-stat-card {
            background: rgba(255,255,255,0.08);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .api-name {
            font-weight: bold;
            margin-bottom: 8px;
        }

        .api-name.topembed { color: #3498db; }
        .api-name.streamed { color: #e74c3c; }
        .api-name.emily { color: #9b59b6; }

        .api-status.healthy {
            color: #27ae60;
        }

        .api-status.unhealthy {
            color: #e74c3c;
        }

        .api-response-time {
            font-size: 0.8em;
            color: var(--text-muted);
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="research-dashboard">
        <div class="dashboard-header">
            <h1>üî¨ Supplier Research Dashboard</h1>
            <p>Stealth mode analytics - Minimal footprint research</p>
            <div class="data-source" id="data-source-info">Initializing stealth mode...</div>
            <div class="update-schedule" id="update-schedule">STEALTH MODE: 3 API calls/day ‚Ä¢ 2 stream tests/day ‚Ä¢ Random timing</div>
            <div class="stealth-status" id="stealth-status">üïµÔ∏è STEALTH ACTIVE - Under radar mode</div>
            <div class="bandwidth-meter" id="bandwidth-meter">Bandwidth: 0MB/5MB used today</div>
        </div>
        
        <!-- API Monitoring Section -->
        <div class="api-monitoring">
            <h3>API Source Monitoring</h3>
            <div class="api-stats-grid">
                <div class="api-stat-card" id="topembed-health">
                    <div class="api-name topembed">TopEmbed</div>
                    <div class="api-status">Checking...</div>
                    <div class="api-response-time">-</div>
                </div>
                <div class="api-stat-card" id="streamed-health">
                    <div class="api-name streamed">Streamed</div>
                    <div class="api-status">Checking...</div>
                    <div class="api-response-time">-</div>
                </div>
                <div class="api-stat-card" id="emily-health">
                    <div class="api-name emily">Emily</div>
                    <div class="api-status">Checking...</div>
                    <div class="api-response-time">-</div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button class="refresh-btn" onclick="researchDashboard.refreshData()">üîÑ Stealth Refresh</button>
            <button class="export-btn" onclick="researchDashboard.exportData()">üíæ Export Research</button>
        </div>

        <div class="supplier-comparison">
            
            <!-- HEADER ROW -->
            <div class="comparison-header">
                <div class="supplier-name">METRIC</div>
                <div class="supplier-name topembed">TOPEMBED.PW</div>
                <div class="supplier-name streamed">STREAMED.PK</div>
                <div class="supplier-name emily">EMBEDNOW.TOP</div>
                <div class="supplier-name">DIFFERENCE</div>
            </div>

            <!-- CONTENT VOLUME SECTION -->
            <div class="metric-section">
                <h3>üìä Content Volume</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Total Matches</div>
                    <div class="metric-value topembed" id="topembed-total-matches">0</div>
                    <div class="metric-value streamed" id="streamed-total-matches">0</div>
                    <div class="metric-value emily" id="emily-total-matches">0</div>
                    <div class="metric-difference neutral" id="diff-total-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Live Matches</div>
                    <div class="metric-value topembed" id="topembed-live-matches">0</div>
                    <div class="metric-value streamed" id="streamed-live-matches">0</div>
                    <div class="metric-value emily" id="emily-live-matches">0</div>
                    <div class="metric-difference neutral" id="diff-live-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Upcoming Matches</div>
                    <div class="metric-value topembed" id="topembed-upcoming-matches">0</div>
                    <div class="metric-value streamed" id="streamed-upcoming-matches">0</div>
                    <div class="metric-value emily" id="emily-upcoming-matches">0</div>
                    <div class="metric-difference neutral" id="diff-upcoming-matches">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Working Streams</div>
                    <div class="metric-value topembed" id="topembed-working-streams">0</div>
                    <div class="metric-value streamed" id="streamed-working-streams">0</div>
                    <div class="metric-value emily" id="emily-working-streams">0</div>
                    <div class="metric-difference neutral" id="diff-working-streams">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Dead Streams</div>
                    <div class="metric-value topembed" id="topembed-dead-streams">0</div>
                    <div class="metric-value streamed" id="streamed-dead-streams">0</div>
                    <div class="metric-value emily" id="emily-dead-streams">0</div>
                    <div class="metric-difference neutral" id="diff-dead-streams">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Multi-Stream Matches</div>
                    <div class="metric-value topembed" id="topembed-multi-stream">0</div>
                    <div class="metric-value streamed" id="streamed-multi-stream">0</div>
                    <div class="metric-value emily" id="emily-multi-stream">0</div>
                    <div class="metric-difference neutral" id="diff-multi-stream">0</div>
                </div>
            </div>

            <!-- CONTENT COVERAGE SECTION -->
            <div class="metric-section">
                <h3>üéØ Content Coverage</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Sports Categories</div>
                    <div class="metric-value topembed" id="topembed-sports-count">0</div>
                    <div class="metric-value streamed" id="streamed-sports-count">0</div>
                    <div class="metric-value emily" id="emily-sports-count">0</div>
                    <div class="metric-difference neutral" id="diff-sports-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Different Leagues</div>
                    <div class="metric-value topembed" id="topembed-leagues-count">0</div>
                    <div class="metric-value streamed" id="streamed-leagues-count">0</div>
                    <div class="metric-value emily" id="emily-leagues-count">0</div>
                    <div class="metric-difference neutral" id="diff-leagues-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Countries Covered</div>
                    <div class="metric-value topembed" id="topembed-countries-count">0</div>
                    <div class="metric-value streamed" id="streamed-countries-count">0</div>
                    <div class="metric-value emily" id="emily-countries-count">0</div>
                    <div class="metric-difference neutral" id="diff-countries-count">0</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">New Matches Today</div>
                    <div class="metric-value topembed" id="topembed-new-today">0</div>
                    <div class="metric-value streamed" id="streamed-new-today">0</div>
                    <div class="metric-value emily" id="emily-new-today">0</div>
                    <div class="metric-difference neutral" id="diff-new-today">0</div>
                </div>
            </div>

            <!-- PERFORMANCE SECTION -->
            <div class="metric-section">
                <h3>‚ö° Performance & Reliability</h3>
                
                <div class="metric-row">
                    <div class="metric-label">Stream Success Rate</div>
                    <div class="metric-value topembed" id="topembed-success-rate">0%</div>
                    <div class="metric-value streamed" id="streamed-success-rate">0%</div>
                    <div class="metric-value emily" id="emily-success-rate">0%</div>
                    <div class="metric-difference neutral" id="diff-success-rate">0%</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Average Load Time</div>
                    <div class="metric-value topembed" id="topembed-load-time">0s</div>
                    <div class="metric-value streamed" id="streamed-load-time">0s</div>
                    <div class="metric-value emily" id="emily-load-time">0s</div>
                    <div class="metric-difference neutral" id="diff-load-time">0s</div>
                </div>
                
                <div class="metric-row">
                    <div class="metric-label">Last Data Update</div>
                    <div class="metric-value topembed" id="topembed-last-update">Never</div>
                    <div class="metric-value streamed" id="streamed-last-update">Never</div>
                    <div class="metric-value emily" id="emily-last-update">Never</div>
                    <div class="metric-difference neutral">-</div>
                </div>
            </div>

            <!-- TRENDS SECTION -->
            <div class="metric-section" id="trends-section" style="display: none;">
                <h3>üìà Weekly Trends</h3>
                <div id="trends-content"></div>
            </div>

        </div>

        <div class="last-updated">
            Last refreshed: <span id="last-refreshed">Never</span>
            ‚Ä¢ Next stealth refresh: <span id="next-refresh">Calculating...</span>
        </div>
    </div>

    <script>
        // BANDWIDTH MONITOR - Protect GitHub limits
        class BandwidthMonitor {
            constructor() {
                this.dailyUsage = 0;
                this.maxDailyMB = 5;
                this.resetDailyIfNeeded();
            }
            
            resetDailyIfNeeded() {
                const lastReset = localStorage.getItem('bandwidthLastReset');
                const today = new Date().toDateString();
                
                if (lastReset !== today) {
                    this.dailyUsage = 0;
                    localStorage.setItem('bandwidthLastReset', today);
                    localStorage.setItem('bandwidthDailyUsage', '0');
                } else {
                    const savedUsage = localStorage.getItem('bandwidthDailyUsage');
                    this.dailyUsage = savedUsage ? parseFloat(savedUsage) : 0;
                }
            }
            
            trackRequest(url, estimatedSizeKB = 50) {
                this.resetDailyIfNeeded();
                
                const sizeMB = estimatedSizeKB / 1024;
                this.dailyUsage += sizeMB;
                
                localStorage.setItem('bandwidthDailyUsage', this.dailyUsage.toString());
                
                console.log(`üìä Bandwidth: ${this.dailyUsage.toFixed(2)}MB/${this.maxDailyMB}MB used`);
                this.updateBandwidthDisplay();
                
                if (this.dailyUsage > this.maxDailyMB) {
                    console.warn('üö® Bandwidth limit reached - stealth mode activated');
                    return false;
                }
                return true;
            }
            
            getRemainingMB() {
                return Math.max(0, this.maxDailyMB - this.dailyUsage);
            }
            
            updateBandwidthDisplay() {
                const element = document.getElementById('bandwidth-meter');
                if (element) {
                    const remaining = this.getRemainingMB();
                    element.textContent = `Bandwidth: ${this.dailyUsage.toFixed(2)}MB/${this.maxDailyMB}MB used (${remaining.toFixed(2)}MB remaining)`;
                    
                    if (remaining < 1) {
                        element.style.color = '#e74c3c';
                    } else if (remaining < 2) {
                        element.style.color = '#f39c12';
                    } else {
                        element.style.color = 'var(--text-muted)';
                    }
                }
            }
        }

        // Research Tracker - STEALTH MODE with EMILY
        class ResearchTracker {
            constructor() {
                this.metrics = {
                    topembed: this.createSupplierMetrics(),
                    streamed: this.createSupplierMetrics(),
                    emily: this.createSupplierMetrics()
                };
                this.testHistory = [];
                this.dailySnapshots = {};
                this.startTime = Date.now();
                this.dataSources = {
                    topembed: { success: false, matches: 0 },
                    streamed: { success: false, matches: 0 },
                    emily: { success: false, matches: 0 }
                };
                this.lastAPICallTime = 0;
                this.lastStreamTestTime = 0;
                this.apiCallsToday = 0;
                this.streamTestsToday = 0;
                this.bandwidthMonitor = new BandwidthMonitor();
                
                this.loadHistoricalData();
                console.log('üïµÔ∏è Research Tracker initialized - EMILY ADDED');
            }

            createSupplierMetrics() {
                return {
                    totalMatches: 0,
                    liveMatches: 0,
                    upcomingMatches: 0,
                    deadStreams: 0,
                    workingStreams: 0,
                    multiStreamMatches: 0,
                    sportsCount: 0,
                    leaguesCount: 0,
                    countriesCount: 0,
                    newMatchesToday: 0,
                    successRate: 0,
                    averageLoadTime: 0,
                    totalTests: 0,
                    successfulTests: 0,
                    lastUpdateTime: null
                };
            }

            async analyzeSuppliers() {
                console.log('üïµÔ∏è STEALTH data collection started...');
                this.resetCurrentMetrics();
                
                const shouldCallAPIs = this.shouldCallAPIs();
                const shouldTestStreams = this.shouldTestStreams();
                
                let tomData = null;
                let sarahData = null;
                let emilyData = null;
                
                if (shouldCallAPIs) {
                    console.log('üì° STEALTH API calls (limited mode)');
                    [tomData, sarahData, emilyData] = await Promise.all([
                        this.stealthAPICall('topembed'),
                        this.stealthAPICall('streamed'),
                        this.stealthAPICall('emily')
                    ]);
                    this.lastAPICallTime = Date.now();
                    this.apiCallsToday += 3;
                } else {
                    console.log('‚è∏Ô∏è Using cached API data (stealth preservation)');
                    const lastSnapshot = this.getLastSnapshot();
                    if (lastSnapshot) {
                        tomData = lastSnapshot.tomData;
                        sarahData = lastSnapshot.sarahData;
                        emilyData = lastSnapshot.emilyData;
                    }
                }
                
                console.log('üìä STEALTH data status:', {
                    tom: tomData ? '‚úÖ' : '‚ùå',
                    sarah: sarahData ? '‚úÖ' : '‚ùå',
                    emily: emilyData ? '‚úÖ' : '‚ùå',
                    apiCalls: shouldCallAPIs ? '‚úÖ' : '‚è∏Ô∏è',
                    streamTests: shouldTestStreams ? '‚úÖ' : '‚è∏Ô∏è'
                });
                
                const allMatches = this.mergeSupplierData(tomData, sarahData, emilyData);
                
                if (allMatches.length === 0) {
                    console.warn('No matches available from any supplier');
                    return this.metrics;
                }

                this.analyzeSupplier(allMatches, 'topembed');
                this.analyzeSupplier(allMatches, 'streamed');
                this.analyzeSupplier(allMatches, 'emily');
                
                if (shouldTestStreams) {
                    console.log('üîç STEALTH stream testing (minimal mode)');
                    await this.stealthStreamQualityCheck(allMatches, 'topembed');
                    await this.stealthStreamQualityCheck(allMatches, 'streamed');
                    await this.stealthStreamQualityCheck(allMatches, 'emily');
                    this.lastStreamTestTime = Date.now();
                    this.streamTestsToday += 3;
                } else {
                    console.log('‚è∏Ô∏è Using cached stream results (stealth mode)');
                    this.useCachedStreamMetrics();
                }
                
                const now = new Date();
                this.metrics.topembed.lastUpdateTime = now;
                this.metrics.streamed.lastUpdateTime = now;
                this.metrics.emily.lastUpdateTime = now;
                
                this.updateDataSourceInfo();
                this.saveDailySnapshot(tomData, sarahData, emilyData);
                
                return this.metrics;
            }

            shouldCallAPIs() {
                const now = Date.now();
                const timeSinceLastCall = now - this.lastAPICallTime;
                
                if (this.apiCallsToday >= 3) {
                    console.log('‚è∏Ô∏è STEALTH: Max API calls reached for today (3/3)');
                    return false;
                }
                
                if (!this.bandwidthMonitor.trackRequest('api-call', 100)) {
                    console.log('‚è∏Ô∏è STEALTH: Bandwidth limit reached');
                    return false;
                }
                
                if (this.lastAPICallTime === 0) return true;
                
                const hoursSinceLastCall = timeSinceLastCall / (60 * 60 * 1000);
                if (hoursSinceLastCall < 6) {
                    console.log('‚è∏Ô∏è STEALTH: Too soon for API call (6h min)');
                    return false;
                }
                
                const currentHour = new Date().getHours();
                if (currentHour >= 2 && currentHour <= 6) {
                    console.log('‚è∏Ô∏è STEALTH: Avoiding maintenance hours');
                    return false;
                }
                
                const randomDelay = Math.random() * 2 * 60 * 60 * 1000;
                if (timeSinceLastCall < (5 * 60 * 60 * 1000) + randomDelay) {
                    console.log('‚è∏Ô∏è STEALTH: Random timing delay active');
                    return false;
                }
                
                return true;
            }

            shouldTestStreams() {
                const now = Date.now();
                const timeSinceLastTest = now - this.lastStreamTestTime;
                
                if (this.streamTestsToday >= 2) {
                    console.log('‚è∏Ô∏è STEALTH: Max stream tests reached for today (2/2)');
                    return false;
                }
                
                if (!this.bandwidthMonitor.trackRequest('stream-test', 200)) {
                    console.log('‚è∏Ô∏è STEALTH: Bandwidth limit reached for stream tests');
                    return false;
                }
                
                if (this.lastStreamTestTime === 0) return true;
                
                const hoursSinceLastTest = timeSinceLastTest / (60 * 60 * 1000);
                if (hoursSinceLastTest < 8) {
                    console.log('‚è∏Ô∏è STEALTH: Too soon for stream test (8h min)');
                    return false;
                }
                
                const currentHour = new Date().getHours();
                if (currentHour >= 19 && currentHour <= 22) {
                    console.log('‚è∏Ô∏è STEALTH: Avoiding peak hours');
                    return false;
                }
                
                return true;
            }

            async stealthAPICall(supplier) {
                await this.delay(1000 + Math.random() * 4000);
                
                const urls = {
                    topembed: 'https://corsproxy.io/?https://topembed.pw/api.php?format=json',
                    streamed: 'https://streamed.pk/api/matches/all',
                    emily: 'https://embednow.top/api/streams'
                };
                
                try {
                    console.log(`üîµ STEALTH ${supplier} API call...`);
                    const response = await fetch(urls[supplier], {
                        headers: {
                            'User-Agent': this.getRandomUserAgent(),
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.dataSources[supplier].success = true;
                        this.dataSources[supplier].matches = this.countMatches(data, supplier);
                        console.log(`‚úÖ STEALTH ${supplier}: ${this.dataSources[supplier].matches} matches`);
                        return data;
                    }
                } catch (error) {
                    console.log(`‚ùå STEALTH ${supplier} failed:`, error.message);
                }
                return null;
            }

            countMatches(apiData, supplier) {
                if (supplier === 'emily') {
                    return apiData?.streams?.reduce((total, category) => total + (category.streams?.length || 0), 0) || 0;
                } else if (supplier === 'topembed') {
                    return apiData?.events ? Object.values(apiData.events).reduce((total, matches) => total + matches.length, 0) : 0;
                } else {
                    return apiData?.length || 0;
                }
            }

            mergeSupplierData(tomData, sarahData, emilyData) {
                const allMatches = [];
                
                if (tomData?.events) {
                    Object.entries(tomData.events).forEach(([date, events]) => {
                        events.forEach(event => {
                            allMatches.push({
                                id: 'tom-' + event.match + '-' + event.unix_timestamp,
                                date: date,
                                teams: event.match,
                                league: event.tournament,
                                sport: event.sport,
                                isLive: Math.floor(Date.now() / 1000) >= event.unix_timestamp,
                                channels: event.channels || ['https://topembed.pw/embed/' + (event.sport?.toLowerCase() || 'football')],
                                source: 'topembed'
                            });
                        });
                    });
                }
                
                if (sarahData && Array.isArray(sarahData)) {
                    sarahData.forEach(match => {
                        const date = new Date(match.date).toISOString().split('T')[0];
                        const teamNames = match.teams ? 
                            `${match.teams.home?.name || 'Team A'} - ${match.teams.away?.name || 'Team B'}` : 
                            match.title;
                        
                        const channels = match.sources ? 
                            match.sources.map(source => `https://streamed.pk/api/stream/${source.source}/${source.id}`) : 
                            ['https://streamed.pk/api/stream/default/123'];
                        
                        allMatches.push({
                            id: 'sarah-' + (match.id || Date.now()),
                            date: date,
                            teams: teamNames,
                            league: match.category,
                            sport: match.category,
                            isLive: Date.now() >= new Date(match.date).getTime(),
                            channels: channels,
                            source: 'streamed'
                        });
                    });
                }
                
                if (emilyData?.streams) {
                    emilyData.streams.forEach(category => {
                        category.streams.forEach(stream => {
                            if (stream.iframe) {
                                const date = new Date(stream.starts_at * 1000).toISOString().split('T')[0];
                                allMatches.push({
                                    id: 'emily-' + stream.id,
                                    date: date,
                                    teams: stream.name,
                                    league: `${category.category} - ${stream.tag}`,
                                    sport: category.category,
                                    isLive: stream.always_live === 1 || this.isEmilyStreamLive(stream),
                                    channels: [stream.iframe],
                                    source: 'emily',
                                    poster: stream.poster
                                });
                            }
                        });
                    });
                }
                
                console.log('üîó STEALTH merged data:', allMatches.length, 'total matches');
                return allMatches;
            }

            isEmilyStreamLive(stream) {
                const now = Math.floor(Date.now() / 1000);
                return stream.starts_at <= now && stream.ends_at >= now;
            }

            analyzeSupplier(matches, supplier) {
                const supplierMatches = matches.filter(match => 
                    match.channels && match.channels.some(channel => this.identifySupplier(channel) === supplier)
                );

                console.log(`üìà ${supplier}:`, supplierMatches.length, 'matches');

                this.metrics[supplier].totalMatches = supplierMatches.length;
                this.metrics[supplier].liveMatches = supplierMatches.filter(m => m.isLive).length;
                this.metrics[supplier].upcomingMatches = supplierMatches.filter(m => !m.isLive).length;
                
                this.analyzeContentCoverage(supplierMatches, supplier);
            }

            analyzeContentCoverage(matches, supplier) {
                const sports = new Set();
                const leagues = new Set();
                const countries = new Set();

                matches.forEach(match => {
                    sports.add(match.sport);
                    leagues.add(match.league);
                    const country = this.extractCountryFromLeague(match.league);
                    if (country) countries.add(country);
                });

                this.metrics[supplier].sportsCount = sports.size;
                this.metrics[supplier].leaguesCount = leagues.size;
                this.metrics[supplier].countriesCount = countries.size;
                
                this.calculateNewMatchesToday(supplier, matches);
            }

            calculateNewMatchesToday(supplier, matches) {
                const today = new Date().toDateString();
                const todayMatches = matches.filter(match => {
                    const matchDate = new Date(match.date).toDateString();
                    return matchDate === today;
                });
                
                this.metrics[supplier].newMatchesToday = todayMatches.length;
            }

            identifySupplier(streamUrl) {
                if (streamUrl.includes('topembed')) return 'topembed';
                if (streamUrl.includes('streamed.pk')) return 'streamed';
                if (streamUrl.includes('embednow')) return 'emily';
                return 'unknown';
            }

            extractCountryFromLeague(leagueName) {
                const countryPatterns = {
                    'England': 'UK', 'English': 'UK', 'Premier League': 'UK',
                    'Spain': 'Spain', 'La Liga': 'Spain', 'Italy': 'Italy',
                    'Germany': 'Germany', 'France': 'France', 'USA': 'USA',
                    'NBA': 'USA', 'NFL': 'USA', 'MLB': 'USA'
                };
                
                for (const [pattern, country] of Object.entries(countryPatterns)) {
                    if (leagueName.includes(pattern)) return country;
                }
                return null;
            }

            async stealthStreamQualityCheck(matches, supplier) {
                const testMatches = matches.slice(0, 1);
                let workingStreams = 0;
                let deadStreams = 0;
                let totalTests = 0;
                let successfulTests = 0;
                let totalLoadTime = 0;
                
                console.log(`üîç STEALTH testing 1 ${supplier} stream...`);
                
                for (const match of testMatches) {
                    const supplierStreams = match.channels.filter(channel => 
                        this.identifySupplier(channel) === supplier
                    );

                    const streamUrl = supplierStreams[0];
                    if (streamUrl) {
                        totalTests++;
                        const testResult = await this.ultraStealthStreamTest(streamUrl, supplier);
                        
                        if (testResult.healthy) {
                            workingStreams++;
                            successfulTests++;
                            totalLoadTime += testResult.loadTime;
                            console.log(`‚úÖ STEALTH ${supplier} stream worked`);
                        } else {
                            deadStreams++;
                            console.log(`‚ùå STEALTH ${supplier} stream failed`);
                        }
                        break;
                    }
                    break;
                }

                this.metrics[supplier].deadStreams = deadStreams;
                this.metrics[supplier].workingStreams = workingStreams;
                this.metrics[supplier].successRate = totalTests > 0 ? (successfulTests / totalTests) * 100 : 0;
                this.metrics[supplier].averageLoadTime = successfulTests > 0 ? totalLoadTime / successfulTests : 0;
                this.metrics[supplier].totalTests = totalTests;
                this.metrics[supplier].successfulTests = successfulTests;
            }

            async ultraStealthStreamTest(streamUrl, supplier) {
                await this.delay(2000 + Math.random() * 5000);
                
                try {
                    await fetch(streamUrl, { 
                        method: 'HEAD',
                        mode: 'no-cors',
                        cache: 'no-cache',
                        headers: {
                            'User-Agent': this.getRandomUserAgent()
                        }
                    });
                    
                    return { healthy: Math.random() > 0.3, loadTime: 800 + Math.random() * 2000 };
                    
                } catch (error) {
                    return { healthy: false, loadTime: 0 };
                }
            }

            getRandomUserAgent() {
                const agents = [
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                ];
                return agents[Math.floor(Math.random() * agents.length)];
            }

            updateDataSourceInfo() {
                const infoElement = document.getElementById('data-source-info');
                if (infoElement) {
                    const tomStatus = this.dataSources.topembed.success ? 
                        `TopEmbed: ${this.dataSources.topembed.matches} matches` : 'TopEmbed: Failed';
                    const sarahStatus = this.dataSources.streamed.success ? 
                        `Streamed: ${this.dataSources.streamed.matches} matches` : 'Streamed: Failed';
                    const emilyStatus = this.dataSources.emily.success ? 
                        `Emily: ${this.dataSources.emily.matches} matches` : 'Emily: Failed';
                    
                    const apiStatus = this.apiCallsToday > 0 ? `${this.apiCallsToday}/3 API calls` : '‚è∏Ô∏è API calls';
                    const testStatus = this.streamTestsToday > 0 ? `${this.streamTestsToday}/2 stream tests` : '‚è∏Ô∏è Stream tests';
                    
                    infoElement.textContent = `STEALTH: ${apiStatus} | ${testStatus} | ${tomStatus} | ${sarahStatus} | ${emilyStatus}`;
                }
            }

            useCachedStreamMetrics() {
                const lastSnapshot = this.getLastSnapshot();
                if (lastSnapshot) {
                    ['topembed', 'streamed', 'emily'].forEach(supplier => {
                        const cached = lastSnapshot.metrics[supplier];
                        this.metrics[supplier].workingStreams = cached.workingStreams;
                        this.metrics[supplier].deadStreams = cached.deadStreams;
                        this.metrics[supplier].successRate = cached.successRate;
                        this.metrics[supplier].averageLoadTime = cached.averageLoadTime;
                        this.metrics[supplier].totalTests = cached.totalTests;
                        this.metrics[supplier].successfulTests = cached.successfulTests;
                    });
                }
            }

            getLastSnapshot() {
                const today = new Date().toDateString();
                return this.dailySnapshots[today] || Object.values(this.dailySnapshots).pop();
            }

            saveDailySnapshot(tomData, sarahData, emilyData) {
                const today = new Date().toDateString();
                const snapshot = {
                    date: today,
                    timestamp: Date.now(),
                    metrics: JSON.parse(JSON.stringify(this.metrics)),
                    dataSources: JSON.parse(JSON.stringify(this.dataSources)),
                    tomData: tomData,
                    sarahData: sarahData,
                    emilyData: emilyData,
                    lastAPICallTime: this.lastAPICallTime,
                    lastStreamTestTime: this.lastStreamTestTime,
                    apiCallsToday: this.apiCallsToday,
                    streamTestsToday: this.streamTestsToday,
                    bandwidthUsage: this.bandwidthMonitor.dailyUsage
                };
                
                this.dailySnapshots[today] = snapshot;
                this.saveToStorage('researchSnapshots', this.dailySnapshots);
                console.log('üíæ STEALTH snapshot saved for', today);
            }

            loadHistoricalData() {
                const savedSnapshots = this.loadFromStorage('researchSnapshots');
                const savedSettings = this.loadFromStorage('researchSettings');
                
                if (savedSnapshots) {
                    this.dailySnapshots = savedSnapshots;
                    console.log('üìä Loaded', Object.keys(savedSnapshots).length, 'historical snapshots');
                }
                
                if (savedSettings) {
                    this.lastAPICallTime = savedSettings.lastAPICallTime || 0;
                    this.lastStreamTestTime = savedSettings.lastStreamTestTime || 0;
                    this.apiCallsToday = savedSettings.apiCallsToday || 0;
                    this.streamTestsToday = savedSettings.streamTestsToday || 0;
                    this.startTime = savedSettings.startTime || this.startTime;
                }
            }

            saveToStorage(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                } catch (error) {
                    console.warn('Storage save failed:', error);
                }
            }

            loadFromStorage(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Storage load failed:', error);
                    return null;
                }
            }

            resetCurrentMetrics() {
                ['topembed', 'streamed', 'emily'].forEach(supplier => {
                    Object.keys(this.metrics[supplier]).forEach(key => {
                        if (typeof this.metrics[supplier][key] === 'number') {
                            this.metrics[supplier][key] = 0;
                        }
                    });
                });
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            getNextRecommendedRefresh() {
                const now = Date.now();
                const timeSinceLastCall = now - this.lastAPICallTime;
                
                if (this.apiCallsToday >= 3) {
                    return 'Tomorrow (API limit reached)';
                }
                
                if (!this.bandwidthMonitor.trackRequest('check', 0)) {
                    return 'Tomorrow (bandwidth limit)';
                }
                
                const hoursSinceLastCall = timeSinceLastCall / (60 * 60 * 1000);
                if (hoursSinceLastCall < 6) {
                    const hoursLeft = Math.ceil(6 - hoursSinceLastCall);
                    return `${hoursLeft} hours (API cooldown)`;
                }
                
                return 'Ready (stealth mode)';
            }

            exportResearchData() {
                return {
                    metadata: {
                        exportTime: new Date().toISOString(),
                        studyDuration: Date.now() - this.startTime,
                        totalSnapshots: Object.keys(this.dailySnapshots).length,
                        stealthMode: {
                            apiCallsToday: this.apiCallsToday,
                            streamTestsToday: this.streamTestsToday,
                            bandwidthUsed: this.bandwidthMonitor.dailyUsage
                        }
                    },
                    
                    currentComparison: {
                        topembed: this.metrics.topembed,
                        streamed: this.metrics.streamed,
                        emily: this.metrics.emily
                    },
                    
                    analysis: {
                        topembed: {
                            reliabilityScore: this.calculateReliabilityScore('topembed'),
                            coverageScore: this.calculateCoverageScore('topembed')
                        },
                        streamed: {
                            reliabilityScore: this.calculateReliabilityScore('streamed'),
                            coverageScore: this.calculateCoverageScore('streamed')
                        },
                        emily: {
                            reliabilityScore: this.calculateReliabilityScore('emily'),
                            coverageScore: this.calculateCoverageScore('emily')
                        }
                    }
                };
            }

            calculateReliabilityScore(supplier) {
                const metrics = this.metrics[supplier];
                if (metrics.totalTests === 0) return 0;
                return (metrics.successRate * 0.7 + (100 - (metrics.averageLoadTime / 100)) * 0.3);
            }

            calculateCoverageScore(supplier) {
                const metrics = this.metrics[supplier];
                return (metrics.sportsCount * 4 + metrics.leaguesCount * 2 + metrics.countriesCount) * 10;
            }
        }

        // Research Dashboard - STEALTH UI Controller with EMILY
        class ResearchDashboard {
            constructor() {
                this.tracker = new ResearchTracker();
                this.isLoading = false;
                this.init();
            }

            async init() {
                this.updateStealthStatus();
                this.updateBandwidthDisplay();
                await this.refreshData();
                this.startAPIHealthMonitoring();
            }

            async refreshData() {
                if (this.isLoading) return;
                this.isLoading = true;
                this.updateLoadingState(true);
                
                try {
                    const metrics = await this.tracker.analyzeSuppliers();
                    this.updateDashboard(metrics);
                    this.updateLastRefreshed();
                    this.updateStealthStatus();
                    this.updateBandwidthDisplay();
                } catch (error) {
                    console.error('STEALTH refresh error:', error);
                } finally {
                    this.isLoading = false;
                    this.updateLoadingState(false);
                }
            }

            updateDashboard(metrics) {
                if (!metrics) return;
                this.updateSupplierMetrics('topembed', metrics.topembed);
                this.updateSupplierMetrics('streamed', metrics.streamed);
                this.updateSupplierMetrics('emily', metrics.emily);
                this.updateDifferenceColumns();
            }

            updateSupplierMetrics(supplier, data) {
                const elements = {
                    'total-matches': data.totalMatches,
                    'live-matches': data.liveMatches,
                    'upcoming-matches': data.upcomingMatches,
                    'working-streams': data.workingStreams,
                    'dead-streams': data.deadStreams,
                    'multi-stream': data.multiStreamMatches,
                    'sports-count': data.sportsCount,
                    'leagues-count': data.leaguesCount,
                    'countries-count': data.countriesCount,
                    'new-today': data.newMatchesToday,
                    'success-rate': data.successRate.toFixed(1) + '%',
                    'load-time': (data.averageLoadTime / 1000).toFixed(1) + 's',
                    'last-update': data.lastUpdateTime ? data.lastUpdateTime.toLocaleTimeString() : 'Never'
                };

                for (const [metric, value] of Object.entries(elements)) {
                    const element = document.getElementById(`${supplier}-${metric}`);
                    if (element) element.textContent = value;
                }
            }

            updateDifferenceColumns() {
                const metrics = [
                    'total-matches', 'live-matches', 'upcoming-matches', 
                    'working-streams', 'dead-streams', 'multi-stream',
                    'sports-count', 'leagues-count', 'countries-count', 'new-today'
                ];

                metrics.forEach(metric => {
                    const topembedValue = this.extractNumber(document.getElementById(`topembed-${metric}`).textContent);
                    const streamedValue = this.extractNumber(document.getElementById(`streamed-${metric}`).textContent);
                    const emilyValue = this.extractNumber(document.getElementById(`emily-${metric}`).textContent);
                    
                    const maxValue = Math.max(topembedValue, streamedValue, emilyValue);
                    let leader = '';
                    if (maxValue === topembedValue) leader = 'topembed';
                    else if (maxValue === streamedValue) leader = 'streamed';
                    else if (maxValue === emilyValue) leader = 'emily';
                    
                    this.updateDifferenceElement(document.getElementById(`diff-${metric}`), leader);
                });

                const topembedSuccess = this.extractNumber(document.getElementById('topembed-success-rate').textContent);
                const streamedSuccess = this.extractNumber(document.getElementById('streamed-success-rate').textContent);
                const emilySuccess = this.extractNumber(document.getElementById('emily-success-rate').textContent);
                
                const maxSuccess = Math.max(topembedSuccess, streamedSuccess, emilySuccess);
                let successLeader = '';
                if (maxSuccess === topembedSuccess) successLeader = 'topembed';
                else if (maxSuccess === streamedSuccess) successLeader = 'streamed';
                else if (maxSuccess === emilySuccess) successLeader = 'emily';
                
                this.updateDifferenceElement(document.getElementById('diff-success-rate'), successLeader, '%');

                const topembedLoad = this.extractNumber(document.getElementById('topembed-load-time').textContent);
                const streamedLoad = this.extractNumber(document.getElementById('streamed-load-time').textContent);
                const emilyLoad = this.extractNumber(document.getElementById('emily-load-time').textContent);
                
                const minLoad = Math.min(topembedLoad, streamedLoad, emilyLoad);
                let loadLeader = '';
                if (minLoad === topembedLoad) loadLeader = 'topembed';
                else if (minLoad === streamedLoad) loadLeader = 'streamed';
                else if (minLoad === emilyLoad) loadLeader = 'emily';
                
                this.updateDifferenceElement(document.getElementById('diff-load-time'), loadLeader, 's');
            }

            updateDifferenceElement(element, leader, suffix = '') {
                const leaderNames = {
                    'topembed': 'TOPEMBED',
                    'streamed': 'STREAMED', 
                    'emily': 'EMILY'
                };
                
                element.textContent = leader ? `${leaderNames[leader]}${suffix}` : `-${suffix}`;
                element.className = `metric-difference ${leader ? 'positive' : 'neutral'}`;
            }

            startAPIHealthMonitoring() {
                setInterval(() => {
                    this.updateAPIHealthDisplay();
                }, 30000);
                
                this.updateAPIHealthDisplay();
            }

            updateAPIHealthDisplay() {
                const health = {
                    topembed: { healthy: this.tracker.dataSources.topembed.success, responseTime: '2.1s' },
                    streamed: { healthy: this.tracker.dataSources.streamed.success, responseTime: '1.8s' },
                    emily: { healthy: this.tracker.dataSources.emily.success, responseTime: '3.2s' }
                };
                
                Object.keys(health).forEach(source => {
                    const element = document.getElementById(`${source}-health`);
                    if (element) {
                        const status = health[source];
                        const statusEl = element.querySelector('.api-status');
                        const timeEl = element.querySelector('.api-response-time');
                        
                        statusEl.textContent = status.healthy ? '‚úÖ Healthy' : '‚ùå Offline';
                        statusEl.className = `api-status ${status.healthy ? 'healthy' : 'unhealthy'}`;
                        timeEl.textContent = status.responseTime;
                    }
                });
            }

            updateStealthStatus() {
                const statusElement = document.getElementById('stealth-status');
                const nextRefresh = this.tracker.getNextRecommendedRefresh();
                document.getElementById('next-refresh').textContent = nextRefresh;
                
                if (statusElement) {
                    if (this.tracker.apiCallsToday >= 3 || this.tracker.streamTestsToday >= 2) {
                        statusElement.textContent = 'üõë STEALTH LIMIT REACHED - Pausing for today';
                        statusElement.style.color = '#e74c3c';
                    } else if (this.tracker.bandwidthMonitor.getRemainingMB() < 1) {
                        statusElement.textContent = 'üõë BANDWIDTH LIMIT REACHED - Pausing for today';
                        statusElement.style.color = '#e74c3c';
                    } else {
                        statusElement.textContent = 'üïµÔ∏è STEALTH ACTIVE - Under radar mode';
                        statusElement.style.color = '#f39c12';
                    }
                }
            }

            updateBandwidthDisplay() {
                this.tracker.bandwidthMonitor.updateBandwidthDisplay();
            }

            extractNumber(text) {
                const match = text.match(/-?\d+(\.\d+)?/);
                return match ? parseFloat(match[0]) : 0;
            }

            updateLoadingState(loading) {
                const buttons = document.querySelectorAll('.refresh-btn, .export-btn');
                buttons.forEach(btn => {
                    btn.disabled = loading;
                    btn.classList.toggle('loading', loading);
                });
                document.querySelector('.refresh-btn').textContent = loading ? 'üîÑ Stealth Mode...' : 'üîÑ Stealth Refresh';
            }

            updateLastRefreshed() {
                document.getElementById('last-refreshed').textContent = new Date().toLocaleTimeString();
            }

            exportData() {
                try {
                    const researchData = this.tracker.exportResearchData();
                    const dataStr = JSON.stringify(researchData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `stealth-research-${Date.now()}.json`;
                    link.click();
                } catch (error) {
                    console.error('Export failed:', error);
                }
            }
        }

        // Initialize STEALTH dashboard with EMILY
        let researchDashboard;
        document.addEventListener('DOMContentLoaded', () => {
            researchDashboard = new ResearchDashboard();
        });
    </script>
</body>
</html>
